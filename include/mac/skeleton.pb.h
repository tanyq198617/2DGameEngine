// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: skeleton.proto

#ifndef PROTOBUF_skeleton_2eproto__INCLUDED
#define PROTOBUF_skeleton_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace hoolai {
namespace skeleton {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_skeleton_2eproto();
void protobuf_AssignDesc_skeleton_2eproto();
void protobuf_ShutdownFile_skeleton_2eproto();

class skeleton;
class skeleton_bone;
class skeleton_animation;
class skeleton_animation_bone;
class skeleton_animation_bone_frame;
class skeleton_container;
class skeleton_container_image;
class skeleton_image;
class skeleton_position;

enum blendmode {
  normal = 1,
  add = 2,
  subtract = 3,
  multiply = 4,
  darken = 5,
  lighten = 6,
  screen = 7
};
bool blendmode_IsValid(int value);
const blendmode blendmode_MIN = normal;
const blendmode blendmode_MAX = screen;
const int blendmode_ARRAYSIZE = blendmode_MAX + 1;

// ===================================================================

class skeleton_bone : public ::google::protobuf::MessageLite {
 public:
  skeleton_bone();
  virtual ~skeleton_bone();

  skeleton_bone(const skeleton_bone& from);

  inline skeleton_bone& operator=(const skeleton_bone& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const skeleton_bone& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const skeleton_bone* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(skeleton_bone* other);

  // implements Message ----------------------------------------------

  skeleton_bone* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const skeleton_bone& from);
  void MergeFrom(const skeleton_bone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string parent = 2;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 2;
  inline const ::std::string& parent() const;
  inline void set_parent(const ::std::string& value);
  inline void set_parent(const char* value);
  inline void set_parent(const char* value, size_t size);
  inline ::std::string* mutable_parent();
  inline ::std::string* release_parent();
  inline void set_allocated_parent(::std::string* parent);

  // optional float x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:hoolai.skeleton.skeleton.bone)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::std::string* name_;
  ::std::string* parent_;
  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_skeleton_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_skeleton_2eproto();
  #endif
  friend void protobuf_AssignDesc_skeleton_2eproto();
  friend void protobuf_ShutdownFile_skeleton_2eproto();

  void InitAsDefaultInstance();
  static skeleton_bone* default_instance_;
};
// -------------------------------------------------------------------

class skeleton_animation_bone_frame : public ::google::protobuf::MessageLite {
 public:
  skeleton_animation_bone_frame();
  virtual ~skeleton_animation_bone_frame();

  skeleton_animation_bone_frame(const skeleton_animation_bone_frame& from);

  inline skeleton_animation_bone_frame& operator=(const skeleton_animation_bone_frame& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const skeleton_animation_bone_frame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const skeleton_animation_bone_frame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(skeleton_animation_bone_frame* other);

  // implements Message ----------------------------------------------

  skeleton_animation_bone_frame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const skeleton_animation_bone_frame& from);
  void MergeFrom(const skeleton_animation_bone_frame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 duration = 1;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 1;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // optional bool hide = 2 [default = false];
  inline bool has_hide() const;
  inline void clear_hide();
  static const int kHideFieldNumber = 2;
  inline bool hide() const;
  inline void set_hide(bool value);

  // optional float x = 3 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 4 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline float y() const;
  inline void set_y(float value);

  // optional float skewX = 5 [default = 0];
  inline bool has_skewx() const;
  inline void clear_skewx();
  static const int kSkewXFieldNumber = 5;
  inline float skewx() const;
  inline void set_skewx(float value);

  // optional float skewY = 6 [default = 0];
  inline bool has_skewy() const;
  inline void clear_skewy();
  static const int kSkewYFieldNumber = 6;
  inline float skewy() const;
  inline void set_skewy(float value);

  // optional float scaleX = 7 [default = 1];
  inline bool has_scalex() const;
  inline void clear_scalex();
  static const int kScaleXFieldNumber = 7;
  inline float scalex() const;
  inline void set_scalex(float value);

  // optional float scaleY = 8 [default = 1];
  inline bool has_scaley() const;
  inline void clear_scaley();
  static const int kScaleYFieldNumber = 8;
  inline float scaley() const;
  inline void set_scaley(float value);

  // optional string container = 9;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 9;
  inline const ::std::string& container() const;
  inline void set_container(const ::std::string& value);
  inline void set_container(const char* value);
  inline void set_container(const char* value, size_t size);
  inline ::std::string* mutable_container();
  inline ::std::string* release_container();
  inline void set_allocated_container(::std::string* container);

  // optional float tweenEasing = 10 [default = 0];
  inline bool has_tweeneasing() const;
  inline void clear_tweeneasing();
  static const int kTweenEasingFieldNumber = 10;
  inline float tweeneasing() const;
  inline void set_tweeneasing(float value);

  // optional float alphaPercent = 11 [default = 1];
  inline bool has_alphapercent() const;
  inline void clear_alphapercent();
  static const int kAlphaPercentFieldNumber = 11;
  inline float alphapercent() const;
  inline void set_alphapercent(float value);

  // optional float redPercent = 12 [default = 1];
  inline bool has_redpercent() const;
  inline void clear_redpercent();
  static const int kRedPercentFieldNumber = 12;
  inline float redpercent() const;
  inline void set_redpercent(float value);

  // optional float greenPercent = 13 [default = 1];
  inline bool has_greenpercent() const;
  inline void clear_greenpercent();
  static const int kGreenPercentFieldNumber = 13;
  inline float greenpercent() const;
  inline void set_greenpercent(float value);

  // optional float bluePercent = 14 [default = 1];
  inline bool has_bluepercent() const;
  inline void clear_bluepercent();
  static const int kBluePercentFieldNumber = 14;
  inline float bluepercent() const;
  inline void set_bluepercent(float value);

  // optional float alphaAmount = 15 [default = 0];
  inline bool has_alphaamount() const;
  inline void clear_alphaamount();
  static const int kAlphaAmountFieldNumber = 15;
  inline float alphaamount() const;
  inline void set_alphaamount(float value);

  // optional float redAmount = 16 [default = 0];
  inline bool has_redamount() const;
  inline void clear_redamount();
  static const int kRedAmountFieldNumber = 16;
  inline float redamount() const;
  inline void set_redamount(float value);

  // optional float greenAmount = 17 [default = 0];
  inline bool has_greenamount() const;
  inline void clear_greenamount();
  static const int kGreenAmountFieldNumber = 17;
  inline float greenamount() const;
  inline void set_greenamount(float value);

  // optional float blueAmount = 18 [default = 0];
  inline bool has_blueamount() const;
  inline void clear_blueamount();
  static const int kBlueAmountFieldNumber = 18;
  inline float blueamount() const;
  inline void set_blueamount(float value);

  // optional float brightness = 19 [default = 1];
  inline bool has_brightness() const;
  inline void clear_brightness();
  static const int kBrightnessFieldNumber = 19;
  inline float brightness() const;
  inline void set_brightness(float value);

  // optional .hoolai.skeleton.blendmode blend = 20 [default = normal];
  inline bool has_blend() const;
  inline void clear_blend();
  static const int kBlendFieldNumber = 20;
  inline ::hoolai::skeleton::blendmode blend() const;
  inline void set_blend(::hoolai::skeleton::blendmode value);

  // @@protoc_insertion_point(class_scope:hoolai.skeleton.skeleton.animation.bone.frame)
 private:
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_hide();
  inline void clear_has_hide();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_skewx();
  inline void clear_has_skewx();
  inline void set_has_skewy();
  inline void clear_has_skewy();
  inline void set_has_scalex();
  inline void clear_has_scalex();
  inline void set_has_scaley();
  inline void clear_has_scaley();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_tweeneasing();
  inline void clear_has_tweeneasing();
  inline void set_has_alphapercent();
  inline void clear_has_alphapercent();
  inline void set_has_redpercent();
  inline void clear_has_redpercent();
  inline void set_has_greenpercent();
  inline void clear_has_greenpercent();
  inline void set_has_bluepercent();
  inline void clear_has_bluepercent();
  inline void set_has_alphaamount();
  inline void clear_has_alphaamount();
  inline void set_has_redamount();
  inline void clear_has_redamount();
  inline void set_has_greenamount();
  inline void clear_has_greenamount();
  inline void set_has_blueamount();
  inline void clear_has_blueamount();
  inline void set_has_brightness();
  inline void clear_has_brightness();
  inline void set_has_blend();
  inline void clear_has_blend();

  ::google::protobuf::int32 duration_;
  bool hide_;
  float x_;
  float y_;
  float skewx_;
  float skewy_;
  float scalex_;
  float scaley_;
  ::std::string* container_;
  float tweeneasing_;
  float alphapercent_;
  float redpercent_;
  float greenpercent_;
  float bluepercent_;
  float alphaamount_;
  float redamount_;
  float greenamount_;
  float blueamount_;
  float brightness_;
  int blend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_skeleton_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_skeleton_2eproto();
  #endif
  friend void protobuf_AssignDesc_skeleton_2eproto();
  friend void protobuf_ShutdownFile_skeleton_2eproto();

  void InitAsDefaultInstance();
  static skeleton_animation_bone_frame* default_instance_;
};
// -------------------------------------------------------------------

class skeleton_animation_bone : public ::google::protobuf::MessageLite {
 public:
  skeleton_animation_bone();
  virtual ~skeleton_animation_bone();

  skeleton_animation_bone(const skeleton_animation_bone& from);

  inline skeleton_animation_bone& operator=(const skeleton_animation_bone& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const skeleton_animation_bone& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const skeleton_animation_bone* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(skeleton_animation_bone* other);

  // implements Message ----------------------------------------------

  skeleton_animation_bone* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const skeleton_animation_bone& from);
  void MergeFrom(const skeleton_animation_bone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef skeleton_animation_bone_frame frame;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .hoolai.skeleton.skeleton.animation.bone.frame frames = 2;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 2;
  inline const ::hoolai::skeleton::skeleton_animation_bone_frame& frames(int index) const;
  inline ::hoolai::skeleton::skeleton_animation_bone_frame* mutable_frames(int index);
  inline ::hoolai::skeleton::skeleton_animation_bone_frame* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation_bone_frame >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation_bone_frame >*
      mutable_frames();

  // optional float delay = 3 [default = 0];
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 3;
  inline float delay() const;
  inline void set_delay(float value);

  // optional float scale = 4 [default = 1];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 4;
  inline float scale() const;
  inline void set_scale(float value);

  // @@protoc_insertion_point(class_scope:hoolai.skeleton.skeleton.animation.bone)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_scale();
  inline void clear_has_scale();

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation_bone_frame > frames_;
  float delay_;
  float scale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_skeleton_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_skeleton_2eproto();
  #endif
  friend void protobuf_AssignDesc_skeleton_2eproto();
  friend void protobuf_ShutdownFile_skeleton_2eproto();

  void InitAsDefaultInstance();
  static skeleton_animation_bone* default_instance_;
};
// -------------------------------------------------------------------

class skeleton_animation : public ::google::protobuf::MessageLite {
 public:
  skeleton_animation();
  virtual ~skeleton_animation();

  skeleton_animation(const skeleton_animation& from);

  inline skeleton_animation& operator=(const skeleton_animation& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const skeleton_animation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const skeleton_animation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(skeleton_animation* other);

  // implements Message ----------------------------------------------

  skeleton_animation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const skeleton_animation& from);
  void MergeFrom(const skeleton_animation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef skeleton_animation_bone bone;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // optional int32 tweentime = 3 [default = 0];
  inline bool has_tweentime() const;
  inline void clear_tweentime();
  static const int kTweentimeFieldNumber = 3;
  inline ::google::protobuf::int32 tweentime() const;
  inline void set_tweentime(::google::protobuf::int32 value);

  // optional bool loop = 4 [default = false];
  inline bool has_loop() const;
  inline void clear_loop();
  static const int kLoopFieldNumber = 4;
  inline bool loop() const;
  inline void set_loop(bool value);

  // repeated .hoolai.skeleton.skeleton.animation.bone bones = 5;
  inline int bones_size() const;
  inline void clear_bones();
  static const int kBonesFieldNumber = 5;
  inline const ::hoolai::skeleton::skeleton_animation_bone& bones(int index) const;
  inline ::hoolai::skeleton::skeleton_animation_bone* mutable_bones(int index);
  inline ::hoolai::skeleton::skeleton_animation_bone* add_bones();
  inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation_bone >&
      bones() const;
  inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation_bone >*
      mutable_bones();

  // @@protoc_insertion_point(class_scope:hoolai.skeleton.skeleton.animation)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_tweentime();
  inline void clear_has_tweentime();
  inline void set_has_loop();
  inline void clear_has_loop();

  ::std::string* name_;
  ::google::protobuf::int32 duration_;
  ::google::protobuf::int32 tweentime_;
  ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation_bone > bones_;
  bool loop_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_skeleton_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_skeleton_2eproto();
  #endif
  friend void protobuf_AssignDesc_skeleton_2eproto();
  friend void protobuf_ShutdownFile_skeleton_2eproto();

  void InitAsDefaultInstance();
  static skeleton_animation* default_instance_;
};
// -------------------------------------------------------------------

class skeleton_container_image : public ::google::protobuf::MessageLite {
 public:
  skeleton_container_image();
  virtual ~skeleton_container_image();

  skeleton_container_image(const skeleton_container_image& from);

  inline skeleton_container_image& operator=(const skeleton_container_image& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const skeleton_container_image& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const skeleton_container_image* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(skeleton_container_image* other);

  // implements Message ----------------------------------------------

  skeleton_container_image* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const skeleton_container_image& from);
  void MergeFrom(const skeleton_container_image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required float x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:hoolai.skeleton.skeleton.container.image)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::std::string* name_;
  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_skeleton_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_skeleton_2eproto();
  #endif
  friend void protobuf_AssignDesc_skeleton_2eproto();
  friend void protobuf_ShutdownFile_skeleton_2eproto();

  void InitAsDefaultInstance();
  static skeleton_container_image* default_instance_;
};
// -------------------------------------------------------------------

class skeleton_container : public ::google::protobuf::MessageLite {
 public:
  skeleton_container();
  virtual ~skeleton_container();

  skeleton_container(const skeleton_container& from);

  inline skeleton_container& operator=(const skeleton_container& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const skeleton_container& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const skeleton_container* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(skeleton_container* other);

  // implements Message ----------------------------------------------

  skeleton_container* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const skeleton_container& from);
  void MergeFrom(const skeleton_container& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef skeleton_container_image image;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .hoolai.skeleton.skeleton.container.image images = 2;
  inline int images_size() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 2;
  inline const ::hoolai::skeleton::skeleton_container_image& images(int index) const;
  inline ::hoolai::skeleton::skeleton_container_image* mutable_images(int index);
  inline ::hoolai::skeleton::skeleton_container_image* add_images();
  inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_container_image >&
      images() const;
  inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_container_image >*
      mutable_images();

  // optional int32 imageindex = 3 [default = 0];
  inline bool has_imageindex() const;
  inline void clear_imageindex();
  static const int kImageindexFieldNumber = 3;
  inline ::google::protobuf::int32 imageindex() const;
  inline void set_imageindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hoolai.skeleton.skeleton.container)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_imageindex();
  inline void clear_has_imageindex();

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_container_image > images_;
  ::google::protobuf::int32 imageindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_skeleton_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_skeleton_2eproto();
  #endif
  friend void protobuf_AssignDesc_skeleton_2eproto();
  friend void protobuf_ShutdownFile_skeleton_2eproto();

  void InitAsDefaultInstance();
  static skeleton_container* default_instance_;
};
// -------------------------------------------------------------------

class skeleton_image : public ::google::protobuf::MessageLite {
 public:
  skeleton_image();
  virtual ~skeleton_image();

  skeleton_image(const skeleton_image& from);

  inline skeleton_image& operator=(const skeleton_image& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const skeleton_image& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const skeleton_image* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(skeleton_image* other);

  // implements Message ----------------------------------------------

  skeleton_image* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const skeleton_image& from);
  void MergeFrom(const skeleton_image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required float width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline float width() const;
  inline void set_width(float value);

  // required float height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline float height() const;
  inline void set_height(float value);

  // optional string atlas = 5;
  inline bool has_atlas() const;
  inline void clear_atlas();
  static const int kAtlasFieldNumber = 5;
  inline const ::std::string& atlas() const;
  inline void set_atlas(const ::std::string& value);
  inline void set_atlas(const char* value);
  inline void set_atlas(const char* value, size_t size);
  inline ::std::string* mutable_atlas();
  inline ::std::string* release_atlas();
  inline void set_allocated_atlas(::std::string* atlas);

  // @@protoc_insertion_point(class_scope:hoolai.skeleton.skeleton.image)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_atlas();
  inline void clear_has_atlas();

  ::std::string* name_;
  ::std::string* path_;
  float width_;
  float height_;
  ::std::string* atlas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_skeleton_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_skeleton_2eproto();
  #endif
  friend void protobuf_AssignDesc_skeleton_2eproto();
  friend void protobuf_ShutdownFile_skeleton_2eproto();

  void InitAsDefaultInstance();
  static skeleton_image* default_instance_;
};
// -------------------------------------------------------------------

class skeleton_position : public ::google::protobuf::MessageLite {
 public:
  skeleton_position();
  virtual ~skeleton_position();

  skeleton_position(const skeleton_position& from);

  inline skeleton_position& operator=(const skeleton_position& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const skeleton_position& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const skeleton_position* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(skeleton_position* other);

  // implements Message ----------------------------------------------

  skeleton_position* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const skeleton_position& from);
  void MergeFrom(const skeleton_position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required float x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:hoolai.skeleton.skeleton.position)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::std::string* name_;
  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_skeleton_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_skeleton_2eproto();
  #endif
  friend void protobuf_AssignDesc_skeleton_2eproto();
  friend void protobuf_ShutdownFile_skeleton_2eproto();

  void InitAsDefaultInstance();
  static skeleton_position* default_instance_;
};
// -------------------------------------------------------------------

class skeleton : public ::google::protobuf::MessageLite {
 public:
  skeleton();
  virtual ~skeleton();

  skeleton(const skeleton& from);

  inline skeleton& operator=(const skeleton& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const skeleton& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const skeleton* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(skeleton* other);

  // implements Message ----------------------------------------------

  skeleton* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const skeleton& from);
  void MergeFrom(const skeleton& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef skeleton_bone bone;
  typedef skeleton_animation animation;
  typedef skeleton_container container;
  typedef skeleton_image image;
  typedef skeleton_position position;

  // accessors -------------------------------------------------------

  // repeated .hoolai.skeleton.skeleton.animation animations = 1;
  inline int animations_size() const;
  inline void clear_animations();
  static const int kAnimationsFieldNumber = 1;
  inline const ::hoolai::skeleton::skeleton_animation& animations(int index) const;
  inline ::hoolai::skeleton::skeleton_animation* mutable_animations(int index);
  inline ::hoolai::skeleton::skeleton_animation* add_animations();
  inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation >&
      animations() const;
  inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation >*
      mutable_animations();

  // repeated .hoolai.skeleton.skeleton.bone bones = 2;
  inline int bones_size() const;
  inline void clear_bones();
  static const int kBonesFieldNumber = 2;
  inline const ::hoolai::skeleton::skeleton_bone& bones(int index) const;
  inline ::hoolai::skeleton::skeleton_bone* mutable_bones(int index);
  inline ::hoolai::skeleton::skeleton_bone* add_bones();
  inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_bone >&
      bones() const;
  inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_bone >*
      mutable_bones();

  // repeated .hoolai.skeleton.skeleton.container contianers = 3;
  inline int contianers_size() const;
  inline void clear_contianers();
  static const int kContianersFieldNumber = 3;
  inline const ::hoolai::skeleton::skeleton_container& contianers(int index) const;
  inline ::hoolai::skeleton::skeleton_container* mutable_contianers(int index);
  inline ::hoolai::skeleton::skeleton_container* add_contianers();
  inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_container >&
      contianers() const;
  inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_container >*
      mutable_contianers();

  // repeated .hoolai.skeleton.skeleton.image images = 4;
  inline int images_size() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 4;
  inline const ::hoolai::skeleton::skeleton_image& images(int index) const;
  inline ::hoolai::skeleton::skeleton_image* mutable_images(int index);
  inline ::hoolai::skeleton::skeleton_image* add_images();
  inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_image >&
      images() const;
  inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_image >*
      mutable_images();

  // repeated .hoolai.skeleton.skeleton.position positions = 5;
  inline int positions_size() const;
  inline void clear_positions();
  static const int kPositionsFieldNumber = 5;
  inline const ::hoolai::skeleton::skeleton_position& positions(int index) const;
  inline ::hoolai::skeleton::skeleton_position* mutable_positions(int index);
  inline ::hoolai::skeleton::skeleton_position* add_positions();
  inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_position >&
      positions() const;
  inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_position >*
      mutable_positions();

  // @@protoc_insertion_point(class_scope:hoolai.skeleton.skeleton)
 private:

  ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation > animations_;
  ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_bone > bones_;
  ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_container > contianers_;
  ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_image > images_;
  ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_position > positions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_skeleton_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_skeleton_2eproto();
  #endif
  friend void protobuf_AssignDesc_skeleton_2eproto();
  friend void protobuf_ShutdownFile_skeleton_2eproto();

  void InitAsDefaultInstance();
  static skeleton* default_instance_;
};
// ===================================================================


// ===================================================================

// skeleton_bone

// required string name = 1;
inline bool skeleton_bone::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skeleton_bone::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skeleton_bone::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skeleton_bone::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& skeleton_bone::name() const {
  return *name_;
}
inline void skeleton_bone::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_bone::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_bone::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_bone::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* skeleton_bone::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_bone::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string parent = 2;
inline bool skeleton_bone::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skeleton_bone::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skeleton_bone::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skeleton_bone::clear_parent() {
  if (parent_ != &::google::protobuf::internal::kEmptyString) {
    parent_->clear();
  }
  clear_has_parent();
}
inline const ::std::string& skeleton_bone::parent() const {
  return *parent_;
}
inline void skeleton_bone::set_parent(const ::std::string& value) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::kEmptyString) {
    parent_ = new ::std::string;
  }
  parent_->assign(value);
}
inline void skeleton_bone::set_parent(const char* value) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::kEmptyString) {
    parent_ = new ::std::string;
  }
  parent_->assign(value);
}
inline void skeleton_bone::set_parent(const char* value, size_t size) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::kEmptyString) {
    parent_ = new ::std::string;
  }
  parent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_bone::mutable_parent() {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::kEmptyString) {
    parent_ = new ::std::string;
  }
  return parent_;
}
inline ::std::string* skeleton_bone::release_parent() {
  clear_has_parent();
  if (parent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parent_;
    parent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_bone::set_allocated_parent(::std::string* parent) {
  if (parent_ != &::google::protobuf::internal::kEmptyString) {
    delete parent_;
  }
  if (parent) {
    set_has_parent();
    parent_ = parent;
  } else {
    clear_has_parent();
    parent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float x = 3;
inline bool skeleton_bone::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skeleton_bone::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skeleton_bone::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skeleton_bone::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float skeleton_bone::x() const {
  return x_;
}
inline void skeleton_bone::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 4;
inline bool skeleton_bone::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void skeleton_bone::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void skeleton_bone::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void skeleton_bone::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float skeleton_bone::y() const {
  return y_;
}
inline void skeleton_bone::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// skeleton_animation_bone_frame

// required int32 duration = 1;
inline bool skeleton_animation_bone_frame::has_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skeleton_animation_bone_frame::clear_has_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skeleton_animation_bone_frame::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 skeleton_animation_bone_frame::duration() const {
  return duration_;
}
inline void skeleton_animation_bone_frame::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
}

// optional bool hide = 2 [default = false];
inline bool skeleton_animation_bone_frame::has_hide() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_hide() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skeleton_animation_bone_frame::clear_has_hide() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skeleton_animation_bone_frame::clear_hide() {
  hide_ = false;
  clear_has_hide();
}
inline bool skeleton_animation_bone_frame::hide() const {
  return hide_;
}
inline void skeleton_animation_bone_frame::set_hide(bool value) {
  set_has_hide();
  hide_ = value;
}

// optional float x = 3 [default = 0];
inline bool skeleton_animation_bone_frame::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skeleton_animation_bone_frame::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skeleton_animation_bone_frame::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float skeleton_animation_bone_frame::x() const {
  return x_;
}
inline void skeleton_animation_bone_frame::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 4 [default = 0];
inline bool skeleton_animation_bone_frame::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void skeleton_animation_bone_frame::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void skeleton_animation_bone_frame::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float skeleton_animation_bone_frame::y() const {
  return y_;
}
inline void skeleton_animation_bone_frame::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float skewX = 5 [default = 0];
inline bool skeleton_animation_bone_frame::has_skewx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_skewx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void skeleton_animation_bone_frame::clear_has_skewx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void skeleton_animation_bone_frame::clear_skewx() {
  skewx_ = 0;
  clear_has_skewx();
}
inline float skeleton_animation_bone_frame::skewx() const {
  return skewx_;
}
inline void skeleton_animation_bone_frame::set_skewx(float value) {
  set_has_skewx();
  skewx_ = value;
}

// optional float skewY = 6 [default = 0];
inline bool skeleton_animation_bone_frame::has_skewy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_skewy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void skeleton_animation_bone_frame::clear_has_skewy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void skeleton_animation_bone_frame::clear_skewy() {
  skewy_ = 0;
  clear_has_skewy();
}
inline float skeleton_animation_bone_frame::skewy() const {
  return skewy_;
}
inline void skeleton_animation_bone_frame::set_skewy(float value) {
  set_has_skewy();
  skewy_ = value;
}

// optional float scaleX = 7 [default = 1];
inline bool skeleton_animation_bone_frame::has_scalex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_scalex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void skeleton_animation_bone_frame::clear_has_scalex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void skeleton_animation_bone_frame::clear_scalex() {
  scalex_ = 1;
  clear_has_scalex();
}
inline float skeleton_animation_bone_frame::scalex() const {
  return scalex_;
}
inline void skeleton_animation_bone_frame::set_scalex(float value) {
  set_has_scalex();
  scalex_ = value;
}

// optional float scaleY = 8 [default = 1];
inline bool skeleton_animation_bone_frame::has_scaley() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_scaley() {
  _has_bits_[0] |= 0x00000080u;
}
inline void skeleton_animation_bone_frame::clear_has_scaley() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void skeleton_animation_bone_frame::clear_scaley() {
  scaley_ = 1;
  clear_has_scaley();
}
inline float skeleton_animation_bone_frame::scaley() const {
  return scaley_;
}
inline void skeleton_animation_bone_frame::set_scaley(float value) {
  set_has_scaley();
  scaley_ = value;
}

// optional string container = 9;
inline bool skeleton_animation_bone_frame::has_container() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_container() {
  _has_bits_[0] |= 0x00000100u;
}
inline void skeleton_animation_bone_frame::clear_has_container() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void skeleton_animation_bone_frame::clear_container() {
  if (container_ != &::google::protobuf::internal::kEmptyString) {
    container_->clear();
  }
  clear_has_container();
}
inline const ::std::string& skeleton_animation_bone_frame::container() const {
  return *container_;
}
inline void skeleton_animation_bone_frame::set_container(const ::std::string& value) {
  set_has_container();
  if (container_ == &::google::protobuf::internal::kEmptyString) {
    container_ = new ::std::string;
  }
  container_->assign(value);
}
inline void skeleton_animation_bone_frame::set_container(const char* value) {
  set_has_container();
  if (container_ == &::google::protobuf::internal::kEmptyString) {
    container_ = new ::std::string;
  }
  container_->assign(value);
}
inline void skeleton_animation_bone_frame::set_container(const char* value, size_t size) {
  set_has_container();
  if (container_ == &::google::protobuf::internal::kEmptyString) {
    container_ = new ::std::string;
  }
  container_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_animation_bone_frame::mutable_container() {
  set_has_container();
  if (container_ == &::google::protobuf::internal::kEmptyString) {
    container_ = new ::std::string;
  }
  return container_;
}
inline ::std::string* skeleton_animation_bone_frame::release_container() {
  clear_has_container();
  if (container_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = container_;
    container_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_animation_bone_frame::set_allocated_container(::std::string* container) {
  if (container_ != &::google::protobuf::internal::kEmptyString) {
    delete container_;
  }
  if (container) {
    set_has_container();
    container_ = container;
  } else {
    clear_has_container();
    container_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float tweenEasing = 10 [default = 0];
inline bool skeleton_animation_bone_frame::has_tweeneasing() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_tweeneasing() {
  _has_bits_[0] |= 0x00000200u;
}
inline void skeleton_animation_bone_frame::clear_has_tweeneasing() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void skeleton_animation_bone_frame::clear_tweeneasing() {
  tweeneasing_ = 0;
  clear_has_tweeneasing();
}
inline float skeleton_animation_bone_frame::tweeneasing() const {
  return tweeneasing_;
}
inline void skeleton_animation_bone_frame::set_tweeneasing(float value) {
  set_has_tweeneasing();
  tweeneasing_ = value;
}

// optional float alphaPercent = 11 [default = 1];
inline bool skeleton_animation_bone_frame::has_alphapercent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_alphapercent() {
  _has_bits_[0] |= 0x00000400u;
}
inline void skeleton_animation_bone_frame::clear_has_alphapercent() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void skeleton_animation_bone_frame::clear_alphapercent() {
  alphapercent_ = 1;
  clear_has_alphapercent();
}
inline float skeleton_animation_bone_frame::alphapercent() const {
  return alphapercent_;
}
inline void skeleton_animation_bone_frame::set_alphapercent(float value) {
  set_has_alphapercent();
  alphapercent_ = value;
}

// optional float redPercent = 12 [default = 1];
inline bool skeleton_animation_bone_frame::has_redpercent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_redpercent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void skeleton_animation_bone_frame::clear_has_redpercent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void skeleton_animation_bone_frame::clear_redpercent() {
  redpercent_ = 1;
  clear_has_redpercent();
}
inline float skeleton_animation_bone_frame::redpercent() const {
  return redpercent_;
}
inline void skeleton_animation_bone_frame::set_redpercent(float value) {
  set_has_redpercent();
  redpercent_ = value;
}

// optional float greenPercent = 13 [default = 1];
inline bool skeleton_animation_bone_frame::has_greenpercent() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_greenpercent() {
  _has_bits_[0] |= 0x00001000u;
}
inline void skeleton_animation_bone_frame::clear_has_greenpercent() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void skeleton_animation_bone_frame::clear_greenpercent() {
  greenpercent_ = 1;
  clear_has_greenpercent();
}
inline float skeleton_animation_bone_frame::greenpercent() const {
  return greenpercent_;
}
inline void skeleton_animation_bone_frame::set_greenpercent(float value) {
  set_has_greenpercent();
  greenpercent_ = value;
}

// optional float bluePercent = 14 [default = 1];
inline bool skeleton_animation_bone_frame::has_bluepercent() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_bluepercent() {
  _has_bits_[0] |= 0x00002000u;
}
inline void skeleton_animation_bone_frame::clear_has_bluepercent() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void skeleton_animation_bone_frame::clear_bluepercent() {
  bluepercent_ = 1;
  clear_has_bluepercent();
}
inline float skeleton_animation_bone_frame::bluepercent() const {
  return bluepercent_;
}
inline void skeleton_animation_bone_frame::set_bluepercent(float value) {
  set_has_bluepercent();
  bluepercent_ = value;
}

// optional float alphaAmount = 15 [default = 0];
inline bool skeleton_animation_bone_frame::has_alphaamount() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_alphaamount() {
  _has_bits_[0] |= 0x00004000u;
}
inline void skeleton_animation_bone_frame::clear_has_alphaamount() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void skeleton_animation_bone_frame::clear_alphaamount() {
  alphaamount_ = 0;
  clear_has_alphaamount();
}
inline float skeleton_animation_bone_frame::alphaamount() const {
  return alphaamount_;
}
inline void skeleton_animation_bone_frame::set_alphaamount(float value) {
  set_has_alphaamount();
  alphaamount_ = value;
}

// optional float redAmount = 16 [default = 0];
inline bool skeleton_animation_bone_frame::has_redamount() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_redamount() {
  _has_bits_[0] |= 0x00008000u;
}
inline void skeleton_animation_bone_frame::clear_has_redamount() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void skeleton_animation_bone_frame::clear_redamount() {
  redamount_ = 0;
  clear_has_redamount();
}
inline float skeleton_animation_bone_frame::redamount() const {
  return redamount_;
}
inline void skeleton_animation_bone_frame::set_redamount(float value) {
  set_has_redamount();
  redamount_ = value;
}

// optional float greenAmount = 17 [default = 0];
inline bool skeleton_animation_bone_frame::has_greenamount() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_greenamount() {
  _has_bits_[0] |= 0x00010000u;
}
inline void skeleton_animation_bone_frame::clear_has_greenamount() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void skeleton_animation_bone_frame::clear_greenamount() {
  greenamount_ = 0;
  clear_has_greenamount();
}
inline float skeleton_animation_bone_frame::greenamount() const {
  return greenamount_;
}
inline void skeleton_animation_bone_frame::set_greenamount(float value) {
  set_has_greenamount();
  greenamount_ = value;
}

// optional float blueAmount = 18 [default = 0];
inline bool skeleton_animation_bone_frame::has_blueamount() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_blueamount() {
  _has_bits_[0] |= 0x00020000u;
}
inline void skeleton_animation_bone_frame::clear_has_blueamount() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void skeleton_animation_bone_frame::clear_blueamount() {
  blueamount_ = 0;
  clear_has_blueamount();
}
inline float skeleton_animation_bone_frame::blueamount() const {
  return blueamount_;
}
inline void skeleton_animation_bone_frame::set_blueamount(float value) {
  set_has_blueamount();
  blueamount_ = value;
}

// optional float brightness = 19 [default = 1];
inline bool skeleton_animation_bone_frame::has_brightness() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_brightness() {
  _has_bits_[0] |= 0x00040000u;
}
inline void skeleton_animation_bone_frame::clear_has_brightness() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void skeleton_animation_bone_frame::clear_brightness() {
  brightness_ = 1;
  clear_has_brightness();
}
inline float skeleton_animation_bone_frame::brightness() const {
  return brightness_;
}
inline void skeleton_animation_bone_frame::set_brightness(float value) {
  set_has_brightness();
  brightness_ = value;
}

// optional .hoolai.skeleton.blendmode blend = 20 [default = normal];
inline bool skeleton_animation_bone_frame::has_blend() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void skeleton_animation_bone_frame::set_has_blend() {
  _has_bits_[0] |= 0x00080000u;
}
inline void skeleton_animation_bone_frame::clear_has_blend() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void skeleton_animation_bone_frame::clear_blend() {
  blend_ = 1;
  clear_has_blend();
}
inline ::hoolai::skeleton::blendmode skeleton_animation_bone_frame::blend() const {
  return static_cast< ::hoolai::skeleton::blendmode >(blend_);
}
inline void skeleton_animation_bone_frame::set_blend(::hoolai::skeleton::blendmode value) {
  assert(::hoolai::skeleton::blendmode_IsValid(value));
  set_has_blend();
  blend_ = value;
}

// -------------------------------------------------------------------

// skeleton_animation_bone

// required string name = 1;
inline bool skeleton_animation_bone::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skeleton_animation_bone::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skeleton_animation_bone::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skeleton_animation_bone::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& skeleton_animation_bone::name() const {
  return *name_;
}
inline void skeleton_animation_bone::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_animation_bone::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_animation_bone::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_animation_bone::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* skeleton_animation_bone::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_animation_bone::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hoolai.skeleton.skeleton.animation.bone.frame frames = 2;
inline int skeleton_animation_bone::frames_size() const {
  return frames_.size();
}
inline void skeleton_animation_bone::clear_frames() {
  frames_.Clear();
}
inline const ::hoolai::skeleton::skeleton_animation_bone_frame& skeleton_animation_bone::frames(int index) const {
  return frames_.Get(index);
}
inline ::hoolai::skeleton::skeleton_animation_bone_frame* skeleton_animation_bone::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::hoolai::skeleton::skeleton_animation_bone_frame* skeleton_animation_bone::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation_bone_frame >&
skeleton_animation_bone::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation_bone_frame >*
skeleton_animation_bone::mutable_frames() {
  return &frames_;
}

// optional float delay = 3 [default = 0];
inline bool skeleton_animation_bone::has_delay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skeleton_animation_bone::set_has_delay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skeleton_animation_bone::clear_has_delay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skeleton_animation_bone::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline float skeleton_animation_bone::delay() const {
  return delay_;
}
inline void skeleton_animation_bone::set_delay(float value) {
  set_has_delay();
  delay_ = value;
}

// optional float scale = 4 [default = 1];
inline bool skeleton_animation_bone::has_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void skeleton_animation_bone::set_has_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void skeleton_animation_bone::clear_has_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void skeleton_animation_bone::clear_scale() {
  scale_ = 1;
  clear_has_scale();
}
inline float skeleton_animation_bone::scale() const {
  return scale_;
}
inline void skeleton_animation_bone::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// -------------------------------------------------------------------

// skeleton_animation

// required string name = 1;
inline bool skeleton_animation::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skeleton_animation::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skeleton_animation::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skeleton_animation::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& skeleton_animation::name() const {
  return *name_;
}
inline void skeleton_animation::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_animation::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_animation::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_animation::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* skeleton_animation::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_animation::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 duration = 2;
inline bool skeleton_animation::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skeleton_animation::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skeleton_animation::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skeleton_animation::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 skeleton_animation::duration() const {
  return duration_;
}
inline void skeleton_animation::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
}

// optional int32 tweentime = 3 [default = 0];
inline bool skeleton_animation::has_tweentime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skeleton_animation::set_has_tweentime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skeleton_animation::clear_has_tweentime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skeleton_animation::clear_tweentime() {
  tweentime_ = 0;
  clear_has_tweentime();
}
inline ::google::protobuf::int32 skeleton_animation::tweentime() const {
  return tweentime_;
}
inline void skeleton_animation::set_tweentime(::google::protobuf::int32 value) {
  set_has_tweentime();
  tweentime_ = value;
}

// optional bool loop = 4 [default = false];
inline bool skeleton_animation::has_loop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void skeleton_animation::set_has_loop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void skeleton_animation::clear_has_loop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void skeleton_animation::clear_loop() {
  loop_ = false;
  clear_has_loop();
}
inline bool skeleton_animation::loop() const {
  return loop_;
}
inline void skeleton_animation::set_loop(bool value) {
  set_has_loop();
  loop_ = value;
}

// repeated .hoolai.skeleton.skeleton.animation.bone bones = 5;
inline int skeleton_animation::bones_size() const {
  return bones_.size();
}
inline void skeleton_animation::clear_bones() {
  bones_.Clear();
}
inline const ::hoolai::skeleton::skeleton_animation_bone& skeleton_animation::bones(int index) const {
  return bones_.Get(index);
}
inline ::hoolai::skeleton::skeleton_animation_bone* skeleton_animation::mutable_bones(int index) {
  return bones_.Mutable(index);
}
inline ::hoolai::skeleton::skeleton_animation_bone* skeleton_animation::add_bones() {
  return bones_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation_bone >&
skeleton_animation::bones() const {
  return bones_;
}
inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation_bone >*
skeleton_animation::mutable_bones() {
  return &bones_;
}

// -------------------------------------------------------------------

// skeleton_container_image

// required string name = 1;
inline bool skeleton_container_image::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skeleton_container_image::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skeleton_container_image::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skeleton_container_image::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& skeleton_container_image::name() const {
  return *name_;
}
inline void skeleton_container_image::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_container_image::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_container_image::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_container_image::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* skeleton_container_image::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_container_image::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float x = 2;
inline bool skeleton_container_image::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skeleton_container_image::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skeleton_container_image::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skeleton_container_image::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float skeleton_container_image::x() const {
  return x_;
}
inline void skeleton_container_image::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 3;
inline bool skeleton_container_image::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skeleton_container_image::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skeleton_container_image::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skeleton_container_image::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float skeleton_container_image::y() const {
  return y_;
}
inline void skeleton_container_image::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// skeleton_container

// required string name = 1;
inline bool skeleton_container::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skeleton_container::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skeleton_container::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skeleton_container::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& skeleton_container::name() const {
  return *name_;
}
inline void skeleton_container::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_container::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_container::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_container::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* skeleton_container::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_container::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .hoolai.skeleton.skeleton.container.image images = 2;
inline int skeleton_container::images_size() const {
  return images_.size();
}
inline void skeleton_container::clear_images() {
  images_.Clear();
}
inline const ::hoolai::skeleton::skeleton_container_image& skeleton_container::images(int index) const {
  return images_.Get(index);
}
inline ::hoolai::skeleton::skeleton_container_image* skeleton_container::mutable_images(int index) {
  return images_.Mutable(index);
}
inline ::hoolai::skeleton::skeleton_container_image* skeleton_container::add_images() {
  return images_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_container_image >&
skeleton_container::images() const {
  return images_;
}
inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_container_image >*
skeleton_container::mutable_images() {
  return &images_;
}

// optional int32 imageindex = 3 [default = 0];
inline bool skeleton_container::has_imageindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skeleton_container::set_has_imageindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skeleton_container::clear_has_imageindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skeleton_container::clear_imageindex() {
  imageindex_ = 0;
  clear_has_imageindex();
}
inline ::google::protobuf::int32 skeleton_container::imageindex() const {
  return imageindex_;
}
inline void skeleton_container::set_imageindex(::google::protobuf::int32 value) {
  set_has_imageindex();
  imageindex_ = value;
}

// -------------------------------------------------------------------

// skeleton_image

// required string name = 1;
inline bool skeleton_image::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skeleton_image::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skeleton_image::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skeleton_image::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& skeleton_image::name() const {
  return *name_;
}
inline void skeleton_image::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_image::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_image::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_image::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* skeleton_image::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_image::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool skeleton_image::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skeleton_image::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skeleton_image::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skeleton_image::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& skeleton_image::path() const {
  return *path_;
}
inline void skeleton_image::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void skeleton_image::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void skeleton_image::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_image::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* skeleton_image::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_image::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float width = 3;
inline bool skeleton_image::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skeleton_image::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skeleton_image::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skeleton_image::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float skeleton_image::width() const {
  return width_;
}
inline void skeleton_image::set_width(float value) {
  set_has_width();
  width_ = value;
}

// required float height = 4;
inline bool skeleton_image::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void skeleton_image::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void skeleton_image::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void skeleton_image::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float skeleton_image::height() const {
  return height_;
}
inline void skeleton_image::set_height(float value) {
  set_has_height();
  height_ = value;
}

// optional string atlas = 5;
inline bool skeleton_image::has_atlas() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void skeleton_image::set_has_atlas() {
  _has_bits_[0] |= 0x00000010u;
}
inline void skeleton_image::clear_has_atlas() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void skeleton_image::clear_atlas() {
  if (atlas_ != &::google::protobuf::internal::kEmptyString) {
    atlas_->clear();
  }
  clear_has_atlas();
}
inline const ::std::string& skeleton_image::atlas() const {
  return *atlas_;
}
inline void skeleton_image::set_atlas(const ::std::string& value) {
  set_has_atlas();
  if (atlas_ == &::google::protobuf::internal::kEmptyString) {
    atlas_ = new ::std::string;
  }
  atlas_->assign(value);
}
inline void skeleton_image::set_atlas(const char* value) {
  set_has_atlas();
  if (atlas_ == &::google::protobuf::internal::kEmptyString) {
    atlas_ = new ::std::string;
  }
  atlas_->assign(value);
}
inline void skeleton_image::set_atlas(const char* value, size_t size) {
  set_has_atlas();
  if (atlas_ == &::google::protobuf::internal::kEmptyString) {
    atlas_ = new ::std::string;
  }
  atlas_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_image::mutable_atlas() {
  set_has_atlas();
  if (atlas_ == &::google::protobuf::internal::kEmptyString) {
    atlas_ = new ::std::string;
  }
  return atlas_;
}
inline ::std::string* skeleton_image::release_atlas() {
  clear_has_atlas();
  if (atlas_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = atlas_;
    atlas_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_image::set_allocated_atlas(::std::string* atlas) {
  if (atlas_ != &::google::protobuf::internal::kEmptyString) {
    delete atlas_;
  }
  if (atlas) {
    set_has_atlas();
    atlas_ = atlas;
  } else {
    clear_has_atlas();
    atlas_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// skeleton_position

// required string name = 1;
inline bool skeleton_position::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skeleton_position::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skeleton_position::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skeleton_position::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& skeleton_position::name() const {
  return *name_;
}
inline void skeleton_position::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_position::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void skeleton_position::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skeleton_position::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* skeleton_position::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skeleton_position::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float x = 2;
inline bool skeleton_position::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skeleton_position::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skeleton_position::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skeleton_position::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float skeleton_position::x() const {
  return x_;
}
inline void skeleton_position::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 3;
inline bool skeleton_position::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skeleton_position::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skeleton_position::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skeleton_position::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float skeleton_position::y() const {
  return y_;
}
inline void skeleton_position::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// skeleton

// repeated .hoolai.skeleton.skeleton.animation animations = 1;
inline int skeleton::animations_size() const {
  return animations_.size();
}
inline void skeleton::clear_animations() {
  animations_.Clear();
}
inline const ::hoolai::skeleton::skeleton_animation& skeleton::animations(int index) const {
  return animations_.Get(index);
}
inline ::hoolai::skeleton::skeleton_animation* skeleton::mutable_animations(int index) {
  return animations_.Mutable(index);
}
inline ::hoolai::skeleton::skeleton_animation* skeleton::add_animations() {
  return animations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation >&
skeleton::animations() const {
  return animations_;
}
inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_animation >*
skeleton::mutable_animations() {
  return &animations_;
}

// repeated .hoolai.skeleton.skeleton.bone bones = 2;
inline int skeleton::bones_size() const {
  return bones_.size();
}
inline void skeleton::clear_bones() {
  bones_.Clear();
}
inline const ::hoolai::skeleton::skeleton_bone& skeleton::bones(int index) const {
  return bones_.Get(index);
}
inline ::hoolai::skeleton::skeleton_bone* skeleton::mutable_bones(int index) {
  return bones_.Mutable(index);
}
inline ::hoolai::skeleton::skeleton_bone* skeleton::add_bones() {
  return bones_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_bone >&
skeleton::bones() const {
  return bones_;
}
inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_bone >*
skeleton::mutable_bones() {
  return &bones_;
}

// repeated .hoolai.skeleton.skeleton.container contianers = 3;
inline int skeleton::contianers_size() const {
  return contianers_.size();
}
inline void skeleton::clear_contianers() {
  contianers_.Clear();
}
inline const ::hoolai::skeleton::skeleton_container& skeleton::contianers(int index) const {
  return contianers_.Get(index);
}
inline ::hoolai::skeleton::skeleton_container* skeleton::mutable_contianers(int index) {
  return contianers_.Mutable(index);
}
inline ::hoolai::skeleton::skeleton_container* skeleton::add_contianers() {
  return contianers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_container >&
skeleton::contianers() const {
  return contianers_;
}
inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_container >*
skeleton::mutable_contianers() {
  return &contianers_;
}

// repeated .hoolai.skeleton.skeleton.image images = 4;
inline int skeleton::images_size() const {
  return images_.size();
}
inline void skeleton::clear_images() {
  images_.Clear();
}
inline const ::hoolai::skeleton::skeleton_image& skeleton::images(int index) const {
  return images_.Get(index);
}
inline ::hoolai::skeleton::skeleton_image* skeleton::mutable_images(int index) {
  return images_.Mutable(index);
}
inline ::hoolai::skeleton::skeleton_image* skeleton::add_images() {
  return images_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_image >&
skeleton::images() const {
  return images_;
}
inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_image >*
skeleton::mutable_images() {
  return &images_;
}

// repeated .hoolai.skeleton.skeleton.position positions = 5;
inline int skeleton::positions_size() const {
  return positions_.size();
}
inline void skeleton::clear_positions() {
  positions_.Clear();
}
inline const ::hoolai::skeleton::skeleton_position& skeleton::positions(int index) const {
  return positions_.Get(index);
}
inline ::hoolai::skeleton::skeleton_position* skeleton::mutable_positions(int index) {
  return positions_.Mutable(index);
}
inline ::hoolai::skeleton::skeleton_position* skeleton::add_positions() {
  return positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_position >&
skeleton::positions() const {
  return positions_;
}
inline ::google::protobuf::RepeatedPtrField< ::hoolai::skeleton::skeleton_position >*
skeleton::mutable_positions() {
  return &positions_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace skeleton
}  // namespace hoolai

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_skeleton_2eproto__INCLUDED
