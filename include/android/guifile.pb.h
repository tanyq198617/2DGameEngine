// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: guifile.proto

#ifndef PROTOBUF_guifile_2eproto__INCLUDED
#define PROTOBUF_guifile_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace hoolai {
namespace gui {
namespace model {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_guifile_2eproto();
void protobuf_AssignDesc_guifile_2eproto();
void protobuf_ShutdownFile_guifile_2eproto();

class Color;
class Rect;
class Scrollview;
class Label;
class ImageView;
class Button;
class Button_TitleNImage;
class EditBox;
class View;

enum View_Type {
  View_Type_kView = 0,
  View_Type_kLabel = 1,
  View_Type_kImageView = 2,
  View_Type_kButton = 3,
  View_Type_kScrollView = 4,
  View_Type_kEditBox = 5
};
bool View_Type_IsValid(int value);
const View_Type View_Type_Type_MIN = View_Type_kView;
const View_Type View_Type_Type_MAX = View_Type_kEditBox;
const int View_Type_Type_ARRAYSIZE = View_Type_Type_MAX + 1;

// ===================================================================

class Color : public ::google::protobuf::MessageLite {
 public:
  Color();
  virtual ~Color();

  Color(const Color& from);

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const Color& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Color* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Color* other);

  // implements Message ----------------------------------------------

  Color* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 r = 1;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 1;
  inline ::google::protobuf::int32 r() const;
  inline void set_r(::google::protobuf::int32 value);

  // required int32 g = 2;
  inline bool has_g() const;
  inline void clear_g();
  static const int kGFieldNumber = 2;
  inline ::google::protobuf::int32 g() const;
  inline void set_g(::google::protobuf::int32 value);

  // required int32 b = 3;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 3;
  inline ::google::protobuf::int32 b() const;
  inline void set_b(::google::protobuf::int32 value);

  // required int32 a = 4;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 4;
  inline ::google::protobuf::int32 a() const;
  inline void set_a(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hoolai.gui.model.Color)
 private:
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_g();
  inline void clear_has_g();
  inline void set_has_b();
  inline void clear_has_b();
  inline void set_has_a();
  inline void clear_has_a();

  ::google::protobuf::int32 r_;
  ::google::protobuf::int32 g_;
  ::google::protobuf::int32 b_;
  ::google::protobuf::int32 a_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_guifile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_guifile_2eproto();
  #endif
  friend void protobuf_AssignDesc_guifile_2eproto();
  friend void protobuf_ShutdownFile_guifile_2eproto();

  void InitAsDefaultInstance();
  static Color* default_instance_;
};
// -------------------------------------------------------------------

class Rect : public ::google::protobuf::MessageLite {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const Rect& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Rect* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Rect* other);

  // implements Message ----------------------------------------------

  Rect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline float width() const;
  inline void set_width(float value);

  // required float height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline float height() const;
  inline void set_height(float value);

  // @@protoc_insertion_point(class_scope:hoolai.gui.model.Rect)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  float x_;
  float y_;
  float width_;
  float height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_guifile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_guifile_2eproto();
  #endif
  friend void protobuf_AssignDesc_guifile_2eproto();
  friend void protobuf_ShutdownFile_guifile_2eproto();

  void InitAsDefaultInstance();
  static Rect* default_instance_;
};
// -------------------------------------------------------------------

class Scrollview : public ::google::protobuf::MessageLite {
 public:
  Scrollview();
  virtual ~Scrollview();

  Scrollview(const Scrollview& from);

  inline Scrollview& operator=(const Scrollview& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const Scrollview& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Scrollview* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Scrollview* other);

  // implements Message ----------------------------------------------

  Scrollview* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Scrollview& from);
  void MergeFrom(const Scrollview& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .hoolai.gui.model.View view = 1;
  inline bool has_view() const;
  inline void clear_view();
  static const int kViewFieldNumber = 1;
  inline const ::hoolai::gui::model::View& view() const;
  inline ::hoolai::gui::model::View* mutable_view();
  inline ::hoolai::gui::model::View* release_view();
  inline void set_allocated_view(::hoolai::gui::model::View* view);

  // @@protoc_insertion_point(class_scope:hoolai.gui.model.Scrollview)
 private:
  inline void set_has_view();
  inline void clear_has_view();

  ::hoolai::gui::model::View* view_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_guifile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_guifile_2eproto();
  #endif
  friend void protobuf_AssignDesc_guifile_2eproto();
  friend void protobuf_ShutdownFile_guifile_2eproto();

  void InitAsDefaultInstance();
  static Scrollview* default_instance_;
};
// -------------------------------------------------------------------

class Label : public ::google::protobuf::MessageLite {
 public:
  Label();
  virtual ~Label();

  Label(const Label& from);

  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const Label& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Label* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Label* other);

  // implements Message ----------------------------------------------

  Label* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Label& from);
  void MergeFrom(const Label& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // required int32 font_size = 2;
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 2;
  inline ::google::protobuf::int32 font_size() const;
  inline void set_font_size(::google::protobuf::int32 value);

  // required .hoolai.gui.model.Color tl_color = 3;
  inline bool has_tl_color() const;
  inline void clear_tl_color();
  static const int kTlColorFieldNumber = 3;
  inline const ::hoolai::gui::model::Color& tl_color() const;
  inline ::hoolai::gui::model::Color* mutable_tl_color();
  inline ::hoolai::gui::model::Color* release_tl_color();
  inline void set_allocated_tl_color(::hoolai::gui::model::Color* tl_color);

  // required .hoolai.gui.model.Color tr_color = 4;
  inline bool has_tr_color() const;
  inline void clear_tr_color();
  static const int kTrColorFieldNumber = 4;
  inline const ::hoolai::gui::model::Color& tr_color() const;
  inline ::hoolai::gui::model::Color* mutable_tr_color();
  inline ::hoolai::gui::model::Color* release_tr_color();
  inline void set_allocated_tr_color(::hoolai::gui::model::Color* tr_color);

  // required .hoolai.gui.model.Color bl_color = 5;
  inline bool has_bl_color() const;
  inline void clear_bl_color();
  static const int kBlColorFieldNumber = 5;
  inline const ::hoolai::gui::model::Color& bl_color() const;
  inline ::hoolai::gui::model::Color* mutable_bl_color();
  inline ::hoolai::gui::model::Color* release_bl_color();
  inline void set_allocated_bl_color(::hoolai::gui::model::Color* bl_color);

  // required .hoolai.gui.model.Color br_color = 6;
  inline bool has_br_color() const;
  inline void clear_br_color();
  static const int kBrColorFieldNumber = 6;
  inline const ::hoolai::gui::model::Color& br_color() const;
  inline ::hoolai::gui::model::Color* mutable_br_color();
  inline ::hoolai::gui::model::Color* release_br_color();
  inline void set_allocated_br_color(::hoolai::gui::model::Color* br_color);

  // required bool stroke = 7;
  inline bool has_stroke() const;
  inline void clear_stroke();
  static const int kStrokeFieldNumber = 7;
  inline bool stroke() const;
  inline void set_stroke(bool value);

  // required bool bold = 8;
  inline bool has_bold() const;
  inline void clear_bold();
  static const int kBoldFieldNumber = 8;
  inline bool bold() const;
  inline void set_bold(bool value);

  // required .hoolai.gui.model.Color stroke_color = 9;
  inline bool has_stroke_color() const;
  inline void clear_stroke_color();
  static const int kStrokeColorFieldNumber = 9;
  inline const ::hoolai::gui::model::Color& stroke_color() const;
  inline ::hoolai::gui::model::Color* mutable_stroke_color();
  inline ::hoolai::gui::model::Color* release_stroke_color();
  inline void set_allocated_stroke_color(::hoolai::gui::model::Color* stroke_color);

  // required int32 text_align = 10;
  inline bool has_text_align() const;
  inline void clear_text_align();
  static const int kTextAlignFieldNumber = 10;
  inline ::google::protobuf::int32 text_align() const;
  inline void set_text_align(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hoolai.gui.model.Label)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_font_size();
  inline void clear_has_font_size();
  inline void set_has_tl_color();
  inline void clear_has_tl_color();
  inline void set_has_tr_color();
  inline void clear_has_tr_color();
  inline void set_has_bl_color();
  inline void clear_has_bl_color();
  inline void set_has_br_color();
  inline void clear_has_br_color();
  inline void set_has_stroke();
  inline void clear_has_stroke();
  inline void set_has_bold();
  inline void clear_has_bold();
  inline void set_has_stroke_color();
  inline void clear_has_stroke_color();
  inline void set_has_text_align();
  inline void clear_has_text_align();

  ::std::string* text_;
  ::hoolai::gui::model::Color* tl_color_;
  ::hoolai::gui::model::Color* tr_color_;
  ::hoolai::gui::model::Color* bl_color_;
  ::google::protobuf::int32 font_size_;
  bool stroke_;
  bool bold_;
  ::hoolai::gui::model::Color* br_color_;
  ::hoolai::gui::model::Color* stroke_color_;
  ::google::protobuf::int32 text_align_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_guifile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_guifile_2eproto();
  #endif
  friend void protobuf_AssignDesc_guifile_2eproto();
  friend void protobuf_ShutdownFile_guifile_2eproto();

  void InitAsDefaultInstance();
  static Label* default_instance_;
};
// -------------------------------------------------------------------

class ImageView : public ::google::protobuf::MessageLite {
 public:
  ImageView();
  virtual ~ImageView();

  ImageView(const ImageView& from);

  inline ImageView& operator=(const ImageView& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const ImageView& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ImageView* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ImageView* other);

  // implements Message ----------------------------------------------

  ImageView* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImageView& from);
  void MergeFrom(const ImageView& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // required .hoolai.gui.model.Rect image_cap = 2;
  inline bool has_image_cap() const;
  inline void clear_image_cap();
  static const int kImageCapFieldNumber = 2;
  inline const ::hoolai::gui::model::Rect& image_cap() const;
  inline ::hoolai::gui::model::Rect* mutable_image_cap();
  inline ::hoolai::gui::model::Rect* release_image_cap();
  inline void set_allocated_image_cap(::hoolai::gui::model::Rect* image_cap);

  // required .hoolai.gui.model.Color tint_color = 3;
  inline bool has_tint_color() const;
  inline void clear_tint_color();
  static const int kTintColorFieldNumber = 3;
  inline const ::hoolai::gui::model::Color& tint_color() const;
  inline ::hoolai::gui::model::Color* mutable_tint_color();
  inline ::hoolai::gui::model::Color* release_tint_color();
  inline void set_allocated_tint_color(::hoolai::gui::model::Color* tint_color);

  // required bool gray = 4;
  inline bool has_gray() const;
  inline void clear_gray();
  static const int kGrayFieldNumber = 4;
  inline bool gray() const;
  inline void set_gray(bool value);

  // required bool repeat = 5;
  inline bool has_repeat() const;
  inline void clear_repeat();
  static const int kRepeatFieldNumber = 5;
  inline bool repeat() const;
  inline void set_repeat(bool value);

  // required float brightness = 6;
  inline bool has_brightness() const;
  inline void clear_brightness();
  static const int kBrightnessFieldNumber = 6;
  inline float brightness() const;
  inline void set_brightness(float value);

  // required bool flip_x = 7;
  inline bool has_flip_x() const;
  inline void clear_flip_x();
  static const int kFlipXFieldNumber = 7;
  inline bool flip_x() const;
  inline void set_flip_x(bool value);

  // required bool flip_y = 8;
  inline bool has_flip_y() const;
  inline void clear_flip_y();
  static const int kFlipYFieldNumber = 8;
  inline bool flip_y() const;
  inline void set_flip_y(bool value);

  // optional string clip_image = 9;
  inline bool has_clip_image() const;
  inline void clear_clip_image();
  static const int kClipImageFieldNumber = 9;
  inline const ::std::string& clip_image() const;
  inline void set_clip_image(const ::std::string& value);
  inline void set_clip_image(const char* value);
  inline void set_clip_image(const char* value, size_t size);
  inline ::std::string* mutable_clip_image();
  inline ::std::string* release_clip_image();
  inline void set_allocated_clip_image(::std::string* clip_image);

  // optional float rotation = 10;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 10;
  inline float rotation() const;
  inline void set_rotation(float value);

  // @@protoc_insertion_point(class_scope:hoolai.gui.model.ImageView)
 private:
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_image_cap();
  inline void clear_has_image_cap();
  inline void set_has_tint_color();
  inline void clear_has_tint_color();
  inline void set_has_gray();
  inline void clear_has_gray();
  inline void set_has_repeat();
  inline void clear_has_repeat();
  inline void set_has_brightness();
  inline void clear_has_brightness();
  inline void set_has_flip_x();
  inline void clear_has_flip_x();
  inline void set_has_flip_y();
  inline void clear_has_flip_y();
  inline void set_has_clip_image();
  inline void clear_has_clip_image();
  inline void set_has_rotation();
  inline void clear_has_rotation();

  ::std::string* image_;
  ::hoolai::gui::model::Rect* image_cap_;
  ::hoolai::gui::model::Color* tint_color_;
  float brightness_;
  bool gray_;
  bool repeat_;
  bool flip_x_;
  bool flip_y_;
  ::std::string* clip_image_;
  float rotation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_guifile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_guifile_2eproto();
  #endif
  friend void protobuf_AssignDesc_guifile_2eproto();
  friend void protobuf_ShutdownFile_guifile_2eproto();

  void InitAsDefaultInstance();
  static ImageView* default_instance_;
};
// -------------------------------------------------------------------

class Button_TitleNImage : public ::google::protobuf::MessageLite {
 public:
  Button_TitleNImage();
  virtual ~Button_TitleNImage();

  Button_TitleNImage(const Button_TitleNImage& from);

  inline Button_TitleNImage& operator=(const Button_TitleNImage& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const Button_TitleNImage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Button_TitleNImage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Button_TitleNImage* other);

  // implements Message ----------------------------------------------

  Button_TitleNImage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Button_TitleNImage& from);
  void MergeFrom(const Button_TitleNImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string image = 2;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 2;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional .hoolai.gui.model.Rect image_cap = 3;
  inline bool has_image_cap() const;
  inline void clear_image_cap();
  static const int kImageCapFieldNumber = 3;
  inline const ::hoolai::gui::model::Rect& image_cap() const;
  inline ::hoolai::gui::model::Rect* mutable_image_cap();
  inline ::hoolai::gui::model::Rect* release_image_cap();
  inline void set_allocated_image_cap(::hoolai::gui::model::Rect* image_cap);

  // optional string clip_image = 4;
  inline bool has_clip_image() const;
  inline void clear_clip_image();
  static const int kClipImageFieldNumber = 4;
  inline const ::std::string& clip_image() const;
  inline void set_clip_image(const ::std::string& value);
  inline void set_clip_image(const char* value);
  inline void set_clip_image(const char* value, size_t size);
  inline ::std::string* mutable_clip_image();
  inline ::std::string* release_clip_image();
  inline void set_allocated_clip_image(::std::string* clip_image);

  // @@protoc_insertion_point(class_scope:hoolai.gui.model.Button.TitleNImage)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_image_cap();
  inline void clear_has_image_cap();
  inline void set_has_clip_image();
  inline void clear_has_clip_image();

  ::std::string* title_;
  ::std::string* image_;
  ::hoolai::gui::model::Rect* image_cap_;
  ::std::string* clip_image_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_guifile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_guifile_2eproto();
  #endif
  friend void protobuf_AssignDesc_guifile_2eproto();
  friend void protobuf_ShutdownFile_guifile_2eproto();

  void InitAsDefaultInstance();
  static Button_TitleNImage* default_instance_;
};
// -------------------------------------------------------------------

class Button : public ::google::protobuf::MessageLite {
 public:
  Button();
  virtual ~Button();

  Button(const Button& from);

  inline Button& operator=(const Button& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const Button& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Button* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Button* other);

  // implements Message ----------------------------------------------

  Button* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Button& from);
  void MergeFrom(const Button& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Button_TitleNImage TitleNImage;

  // accessors -------------------------------------------------------

  // required .hoolai.gui.model.Label label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::hoolai::gui::model::Label& label() const;
  inline ::hoolai::gui::model::Label* mutable_label();
  inline ::hoolai::gui::model::Label* release_label();
  inline void set_allocated_label(::hoolai::gui::model::Label* label);

  // required .hoolai.gui.model.Button.TitleNImage normal = 2;
  inline bool has_normal() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 2;
  inline const ::hoolai::gui::model::Button_TitleNImage& normal() const;
  inline ::hoolai::gui::model::Button_TitleNImage* mutable_normal();
  inline ::hoolai::gui::model::Button_TitleNImage* release_normal();
  inline void set_allocated_normal(::hoolai::gui::model::Button_TitleNImage* normal);

  // optional .hoolai.gui.model.Button.TitleNImage selected = 3;
  inline bool has_selected() const;
  inline void clear_selected();
  static const int kSelectedFieldNumber = 3;
  inline const ::hoolai::gui::model::Button_TitleNImage& selected() const;
  inline ::hoolai::gui::model::Button_TitleNImage* mutable_selected();
  inline ::hoolai::gui::model::Button_TitleNImage* release_selected();
  inline void set_allocated_selected(::hoolai::gui::model::Button_TitleNImage* selected);

  // optional .hoolai.gui.model.Button.TitleNImage highlighted = 4;
  inline bool has_highlighted() const;
  inline void clear_highlighted();
  static const int kHighlightedFieldNumber = 4;
  inline const ::hoolai::gui::model::Button_TitleNImage& highlighted() const;
  inline ::hoolai::gui::model::Button_TitleNImage* mutable_highlighted();
  inline ::hoolai::gui::model::Button_TitleNImage* release_highlighted();
  inline void set_allocated_highlighted(::hoolai::gui::model::Button_TitleNImage* highlighted);

  // optional .hoolai.gui.model.Button.TitleNImage disabled = 5;
  inline bool has_disabled() const;
  inline void clear_disabled();
  static const int kDisabledFieldNumber = 5;
  inline const ::hoolai::gui::model::Button_TitleNImage& disabled() const;
  inline ::hoolai::gui::model::Button_TitleNImage* mutable_disabled();
  inline ::hoolai::gui::model::Button_TitleNImage* release_disabled();
  inline void set_allocated_disabled(::hoolai::gui::model::Button_TitleNImage* disabled);

  // required bool zoom_on_touchdown = 6;
  inline bool has_zoom_on_touchdown() const;
  inline void clear_zoom_on_touchdown();
  static const int kZoomOnTouchdownFieldNumber = 6;
  inline bool zoom_on_touchdown() const;
  inline void set_zoom_on_touchdown(bool value);

  // required bool repeat = 7;
  inline bool has_repeat() const;
  inline void clear_repeat();
  static const int kRepeatFieldNumber = 7;
  inline bool repeat() const;
  inline void set_repeat(bool value);

  // optional int32 state = 8;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 8;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 action = 9;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 9;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hoolai.gui.model.Button)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_normal();
  inline void clear_has_normal();
  inline void set_has_selected();
  inline void clear_has_selected();
  inline void set_has_highlighted();
  inline void clear_has_highlighted();
  inline void set_has_disabled();
  inline void clear_has_disabled();
  inline void set_has_zoom_on_touchdown();
  inline void clear_has_zoom_on_touchdown();
  inline void set_has_repeat();
  inline void clear_has_repeat();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_action();
  inline void clear_has_action();

  ::hoolai::gui::model::Label* label_;
  ::hoolai::gui::model::Button_TitleNImage* normal_;
  ::hoolai::gui::model::Button_TitleNImage* selected_;
  ::hoolai::gui::model::Button_TitleNImage* highlighted_;
  ::hoolai::gui::model::Button_TitleNImage* disabled_;
  bool zoom_on_touchdown_;
  bool repeat_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_guifile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_guifile_2eproto();
  #endif
  friend void protobuf_AssignDesc_guifile_2eproto();
  friend void protobuf_ShutdownFile_guifile_2eproto();

  void InitAsDefaultInstance();
  static Button* default_instance_;
};
// -------------------------------------------------------------------

class EditBox : public ::google::protobuf::MessageLite {
 public:
  EditBox();
  virtual ~EditBox();

  EditBox(const EditBox& from);

  inline EditBox& operator=(const EditBox& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const EditBox& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EditBox* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EditBox* other);

  // implements Message ----------------------------------------------

  EditBox* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EditBox& from);
  void MergeFrom(const EditBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hoolai.gui.model.Label label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::hoolai::gui::model::Label& label() const;
  inline ::hoolai::gui::model::Label* mutable_label();
  inline ::hoolai::gui::model::Label* release_label();
  inline void set_allocated_label(::hoolai::gui::model::Label* label);

  // @@protoc_insertion_point(class_scope:hoolai.gui.model.EditBox)
 private:
  inline void set_has_label();
  inline void clear_has_label();

  ::hoolai::gui::model::Label* label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_guifile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_guifile_2eproto();
  #endif
  friend void protobuf_AssignDesc_guifile_2eproto();
  friend void protobuf_ShutdownFile_guifile_2eproto();

  void InitAsDefaultInstance();
  static EditBox* default_instance_;
};
// -------------------------------------------------------------------

class View : public ::google::protobuf::MessageLite {
 public:
  View();
  virtual ~View();

  View(const View& from);

  inline View& operator=(const View& from) {
    CopyFrom(from);
    return *this;
  }

  void printDebugInfo() const;

  static const View& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const View* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(View* other);

  // implements Message ----------------------------------------------

  View* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const View& from);
  void MergeFrom(const View& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef View_Type Type;
  static const Type kView = View_Type_kView;
  static const Type kLabel = View_Type_kLabel;
  static const Type kImageView = View_Type_kImageView;
  static const Type kButton = View_Type_kButton;
  static const Type kScrollView = View_Type_kScrollView;
  static const Type kEditBox = View_Type_kEditBox;
  static inline bool Type_IsValid(int value) {
    return View_Type_IsValid(value);
  }
  static const Type Type_MIN =
    View_Type_Type_MIN;
  static const Type Type_MAX =
    View_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    View_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string class_name = 2;
  inline bool has_class_name() const;
  inline void clear_class_name();
  static const int kClassNameFieldNumber = 2;
  inline const ::std::string& class_name() const;
  inline void set_class_name(const ::std::string& value);
  inline void set_class_name(const char* value);
  inline void set_class_name(const char* value, size_t size);
  inline ::std::string* mutable_class_name();
  inline ::std::string* release_class_name();
  inline void set_allocated_class_name(::std::string* class_name);

  // required .hoolai.gui.model.View.Type type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::hoolai::gui::model::View_Type type() const;
  inline void set_type(::hoolai::gui::model::View_Type value);

  // required float x = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline float y() const;
  inline void set_y(float value);

  // required float width = 6;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 6;
  inline float width() const;
  inline void set_width(float value);

  // required float height = 7;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 7;
  inline float height() const;
  inline void set_height(float value);

  // optional .hoolai.gui.model.Color bg_color = 8;
  inline bool has_bg_color() const;
  inline void clear_bg_color();
  static const int kBgColorFieldNumber = 8;
  inline const ::hoolai::gui::model::Color& bg_color() const;
  inline ::hoolai::gui::model::Color* mutable_bg_color();
  inline ::hoolai::gui::model::Color* release_bg_color();
  inline void set_allocated_bg_color(::hoolai::gui::model::Color* bg_color);

  // required bool visible = 9;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 9;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional .hoolai.gui.model.Label label = 10;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 10;
  inline const ::hoolai::gui::model::Label& label() const;
  inline ::hoolai::gui::model::Label* mutable_label();
  inline ::hoolai::gui::model::Label* release_label();
  inline void set_allocated_label(::hoolai::gui::model::Label* label);

  // optional .hoolai.gui.model.ImageView image = 11;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 11;
  inline const ::hoolai::gui::model::ImageView& image() const;
  inline ::hoolai::gui::model::ImageView* mutable_image();
  inline ::hoolai::gui::model::ImageView* release_image();
  inline void set_allocated_image(::hoolai::gui::model::ImageView* image);

  // optional .hoolai.gui.model.Button button = 12;
  inline bool has_button() const;
  inline void clear_button();
  static const int kButtonFieldNumber = 12;
  inline const ::hoolai::gui::model::Button& button() const;
  inline ::hoolai::gui::model::Button* mutable_button();
  inline ::hoolai::gui::model::Button* release_button();
  inline void set_allocated_button(::hoolai::gui::model::Button* button);

  // repeated .hoolai.gui.model.View children = 13;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 13;
  inline const ::hoolai::gui::model::View& children(int index) const;
  inline ::hoolai::gui::model::View* mutable_children(int index);
  inline ::hoolai::gui::model::View* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::hoolai::gui::model::View >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::hoolai::gui::model::View >*
      mutable_children();

  // optional int32 tag = 14;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 14;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional .hoolai.gui.model.EditBox editBox = 15;
  inline bool has_editbox() const;
  inline void clear_editbox();
  static const int kEditBoxFieldNumber = 15;
  inline const ::hoolai::gui::model::EditBox& editbox() const;
  inline ::hoolai::gui::model::EditBox* mutable_editbox();
  inline ::hoolai::gui::model::EditBox* release_editbox();
  inline void set_allocated_editbox(::hoolai::gui::model::EditBox* editbox);

  // @@protoc_insertion_point(class_scope:hoolai.gui.model.View)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_class_name();
  inline void clear_has_class_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_bg_color();
  inline void clear_has_bg_color();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_button();
  inline void clear_has_button();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_editbox();
  inline void clear_has_editbox();

  ::std::string* class_name_;
  ::google::protobuf::int32 id_;
  int type_;
  float x_;
  float y_;
  float width_;
  float height_;
  ::hoolai::gui::model::Color* bg_color_;
  ::hoolai::gui::model::Label* label_;
  ::hoolai::gui::model::ImageView* image_;
  bool visible_;
  ::google::protobuf::int32 tag_;
  ::hoolai::gui::model::Button* button_;
  ::google::protobuf::RepeatedPtrField< ::hoolai::gui::model::View > children_;
  ::hoolai::gui::model::EditBox* editbox_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_guifile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_guifile_2eproto();
  #endif
  friend void protobuf_AssignDesc_guifile_2eproto();
  friend void protobuf_ShutdownFile_guifile_2eproto();

  void InitAsDefaultInstance();
  static View* default_instance_;
};
// ===================================================================


// ===================================================================

// Color

// required int32 r = 1;
inline bool Color::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Color::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Color::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Color::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline ::google::protobuf::int32 Color::r() const {
  return r_;
}
inline void Color::set_r(::google::protobuf::int32 value) {
  set_has_r();
  r_ = value;
}

// required int32 g = 2;
inline bool Color::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Color::set_has_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Color::clear_has_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Color::clear_g() {
  g_ = 0;
  clear_has_g();
}
inline ::google::protobuf::int32 Color::g() const {
  return g_;
}
inline void Color::set_g(::google::protobuf::int32 value) {
  set_has_g();
  g_ = value;
}

// required int32 b = 3;
inline bool Color::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Color::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Color::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Color::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline ::google::protobuf::int32 Color::b() const {
  return b_;
}
inline void Color::set_b(::google::protobuf::int32 value) {
  set_has_b();
  b_ = value;
}

// required int32 a = 4;
inline bool Color::has_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Color::set_has_a() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Color::clear_has_a() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Color::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline ::google::protobuf::int32 Color::a() const {
  return a_;
}
inline void Color::set_a(::google::protobuf::int32 value) {
  set_has_a();
  a_ = value;
}

// -------------------------------------------------------------------

// Rect

// required float x = 1;
inline bool Rect::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rect::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rect::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Rect::x() const {
  return x_;
}
inline void Rect::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Rect::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rect::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rect::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Rect::y() const {
  return y_;
}
inline void Rect::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float width = 3;
inline bool Rect::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rect::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rect::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float Rect::width() const {
  return width_;
}
inline void Rect::set_width(float value) {
  set_has_width();
  width_ = value;
}

// required float height = 4;
inline bool Rect::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rect::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rect::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float Rect::height() const {
  return height_;
}
inline void Rect::set_height(float value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// Scrollview

// required .hoolai.gui.model.View view = 1;
inline bool Scrollview::has_view() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scrollview::set_has_view() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scrollview::clear_has_view() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scrollview::clear_view() {
  if (view_ != NULL) view_->::hoolai::gui::model::View::Clear();
  clear_has_view();
}
inline const ::hoolai::gui::model::View& Scrollview::view() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return view_ != NULL ? *view_ : *default_instance().view_;
#else
  return view_ != NULL ? *view_ : *default_instance_->view_;
#endif
}
inline ::hoolai::gui::model::View* Scrollview::mutable_view() {
  set_has_view();
  if (view_ == NULL) view_ = new ::hoolai::gui::model::View;
  return view_;
}
inline ::hoolai::gui::model::View* Scrollview::release_view() {
  clear_has_view();
  ::hoolai::gui::model::View* temp = view_;
  view_ = NULL;
  return temp;
}
inline void Scrollview::set_allocated_view(::hoolai::gui::model::View* view) {
  delete view_;
  view_ = view;
  if (view) {
    set_has_view();
  } else {
    clear_has_view();
  }
}

// -------------------------------------------------------------------

// Label

// optional string text = 1;
inline bool Label::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Label::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Label::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Label::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Label::text() const {
  return *text_;
}
inline void Label::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Label::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Label::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Label::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Label::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 font_size = 2;
inline bool Label::has_font_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Label::set_has_font_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Label::clear_has_font_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Label::clear_font_size() {
  font_size_ = 0;
  clear_has_font_size();
}
inline ::google::protobuf::int32 Label::font_size() const {
  return font_size_;
}
inline void Label::set_font_size(::google::protobuf::int32 value) {
  set_has_font_size();
  font_size_ = value;
}

// required .hoolai.gui.model.Color tl_color = 3;
inline bool Label::has_tl_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Label::set_has_tl_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Label::clear_has_tl_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Label::clear_tl_color() {
  if (tl_color_ != NULL) tl_color_->::hoolai::gui::model::Color::Clear();
  clear_has_tl_color();
}
inline const ::hoolai::gui::model::Color& Label::tl_color() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tl_color_ != NULL ? *tl_color_ : *default_instance().tl_color_;
#else
  return tl_color_ != NULL ? *tl_color_ : *default_instance_->tl_color_;
#endif
}
inline ::hoolai::gui::model::Color* Label::mutable_tl_color() {
  set_has_tl_color();
  if (tl_color_ == NULL) tl_color_ = new ::hoolai::gui::model::Color;
  return tl_color_;
}
inline ::hoolai::gui::model::Color* Label::release_tl_color() {
  clear_has_tl_color();
  ::hoolai::gui::model::Color* temp = tl_color_;
  tl_color_ = NULL;
  return temp;
}
inline void Label::set_allocated_tl_color(::hoolai::gui::model::Color* tl_color) {
  delete tl_color_;
  tl_color_ = tl_color;
  if (tl_color) {
    set_has_tl_color();
  } else {
    clear_has_tl_color();
  }
}

// required .hoolai.gui.model.Color tr_color = 4;
inline bool Label::has_tr_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Label::set_has_tr_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Label::clear_has_tr_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Label::clear_tr_color() {
  if (tr_color_ != NULL) tr_color_->::hoolai::gui::model::Color::Clear();
  clear_has_tr_color();
}
inline const ::hoolai::gui::model::Color& Label::tr_color() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tr_color_ != NULL ? *tr_color_ : *default_instance().tr_color_;
#else
  return tr_color_ != NULL ? *tr_color_ : *default_instance_->tr_color_;
#endif
}
inline ::hoolai::gui::model::Color* Label::mutable_tr_color() {
  set_has_tr_color();
  if (tr_color_ == NULL) tr_color_ = new ::hoolai::gui::model::Color;
  return tr_color_;
}
inline ::hoolai::gui::model::Color* Label::release_tr_color() {
  clear_has_tr_color();
  ::hoolai::gui::model::Color* temp = tr_color_;
  tr_color_ = NULL;
  return temp;
}
inline void Label::set_allocated_tr_color(::hoolai::gui::model::Color* tr_color) {
  delete tr_color_;
  tr_color_ = tr_color;
  if (tr_color) {
    set_has_tr_color();
  } else {
    clear_has_tr_color();
  }
}

// required .hoolai.gui.model.Color bl_color = 5;
inline bool Label::has_bl_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Label::set_has_bl_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Label::clear_has_bl_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Label::clear_bl_color() {
  if (bl_color_ != NULL) bl_color_->::hoolai::gui::model::Color::Clear();
  clear_has_bl_color();
}
inline const ::hoolai::gui::model::Color& Label::bl_color() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bl_color_ != NULL ? *bl_color_ : *default_instance().bl_color_;
#else
  return bl_color_ != NULL ? *bl_color_ : *default_instance_->bl_color_;
#endif
}
inline ::hoolai::gui::model::Color* Label::mutable_bl_color() {
  set_has_bl_color();
  if (bl_color_ == NULL) bl_color_ = new ::hoolai::gui::model::Color;
  return bl_color_;
}
inline ::hoolai::gui::model::Color* Label::release_bl_color() {
  clear_has_bl_color();
  ::hoolai::gui::model::Color* temp = bl_color_;
  bl_color_ = NULL;
  return temp;
}
inline void Label::set_allocated_bl_color(::hoolai::gui::model::Color* bl_color) {
  delete bl_color_;
  bl_color_ = bl_color;
  if (bl_color) {
    set_has_bl_color();
  } else {
    clear_has_bl_color();
  }
}

// required .hoolai.gui.model.Color br_color = 6;
inline bool Label::has_br_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Label::set_has_br_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Label::clear_has_br_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Label::clear_br_color() {
  if (br_color_ != NULL) br_color_->::hoolai::gui::model::Color::Clear();
  clear_has_br_color();
}
inline const ::hoolai::gui::model::Color& Label::br_color() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return br_color_ != NULL ? *br_color_ : *default_instance().br_color_;
#else
  return br_color_ != NULL ? *br_color_ : *default_instance_->br_color_;
#endif
}
inline ::hoolai::gui::model::Color* Label::mutable_br_color() {
  set_has_br_color();
  if (br_color_ == NULL) br_color_ = new ::hoolai::gui::model::Color;
  return br_color_;
}
inline ::hoolai::gui::model::Color* Label::release_br_color() {
  clear_has_br_color();
  ::hoolai::gui::model::Color* temp = br_color_;
  br_color_ = NULL;
  return temp;
}
inline void Label::set_allocated_br_color(::hoolai::gui::model::Color* br_color) {
  delete br_color_;
  br_color_ = br_color;
  if (br_color) {
    set_has_br_color();
  } else {
    clear_has_br_color();
  }
}

// required bool stroke = 7;
inline bool Label::has_stroke() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Label::set_has_stroke() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Label::clear_has_stroke() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Label::clear_stroke() {
  stroke_ = false;
  clear_has_stroke();
}
inline bool Label::stroke() const {
  return stroke_;
}
inline void Label::set_stroke(bool value) {
  set_has_stroke();
  stroke_ = value;
}

// required bool bold = 8;
inline bool Label::has_bold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Label::set_has_bold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Label::clear_has_bold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Label::clear_bold() {
  bold_ = false;
  clear_has_bold();
}
inline bool Label::bold() const {
  return bold_;
}
inline void Label::set_bold(bool value) {
  set_has_bold();
  bold_ = value;
}

// required .hoolai.gui.model.Color stroke_color = 9;
inline bool Label::has_stroke_color() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Label::set_has_stroke_color() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Label::clear_has_stroke_color() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Label::clear_stroke_color() {
  if (stroke_color_ != NULL) stroke_color_->::hoolai::gui::model::Color::Clear();
  clear_has_stroke_color();
}
inline const ::hoolai::gui::model::Color& Label::stroke_color() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stroke_color_ != NULL ? *stroke_color_ : *default_instance().stroke_color_;
#else
  return stroke_color_ != NULL ? *stroke_color_ : *default_instance_->stroke_color_;
#endif
}
inline ::hoolai::gui::model::Color* Label::mutable_stroke_color() {
  set_has_stroke_color();
  if (stroke_color_ == NULL) stroke_color_ = new ::hoolai::gui::model::Color;
  return stroke_color_;
}
inline ::hoolai::gui::model::Color* Label::release_stroke_color() {
  clear_has_stroke_color();
  ::hoolai::gui::model::Color* temp = stroke_color_;
  stroke_color_ = NULL;
  return temp;
}
inline void Label::set_allocated_stroke_color(::hoolai::gui::model::Color* stroke_color) {
  delete stroke_color_;
  stroke_color_ = stroke_color;
  if (stroke_color) {
    set_has_stroke_color();
  } else {
    clear_has_stroke_color();
  }
}

// required int32 text_align = 10;
inline bool Label::has_text_align() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Label::set_has_text_align() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Label::clear_has_text_align() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Label::clear_text_align() {
  text_align_ = 0;
  clear_has_text_align();
}
inline ::google::protobuf::int32 Label::text_align() const {
  return text_align_;
}
inline void Label::set_text_align(::google::protobuf::int32 value) {
  set_has_text_align();
  text_align_ = value;
}

// -------------------------------------------------------------------

// ImageView

// required string image = 1;
inline bool ImageView::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageView::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageView::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageView::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& ImageView::image() const {
  return *image_;
}
inline void ImageView::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void ImageView::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void ImageView::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageView::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* ImageView::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImageView::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .hoolai.gui.model.Rect image_cap = 2;
inline bool ImageView::has_image_cap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageView::set_has_image_cap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageView::clear_has_image_cap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageView::clear_image_cap() {
  if (image_cap_ != NULL) image_cap_->::hoolai::gui::model::Rect::Clear();
  clear_has_image_cap();
}
inline const ::hoolai::gui::model::Rect& ImageView::image_cap() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return image_cap_ != NULL ? *image_cap_ : *default_instance().image_cap_;
#else
  return image_cap_ != NULL ? *image_cap_ : *default_instance_->image_cap_;
#endif
}
inline ::hoolai::gui::model::Rect* ImageView::mutable_image_cap() {
  set_has_image_cap();
  if (image_cap_ == NULL) image_cap_ = new ::hoolai::gui::model::Rect;
  return image_cap_;
}
inline ::hoolai::gui::model::Rect* ImageView::release_image_cap() {
  clear_has_image_cap();
  ::hoolai::gui::model::Rect* temp = image_cap_;
  image_cap_ = NULL;
  return temp;
}
inline void ImageView::set_allocated_image_cap(::hoolai::gui::model::Rect* image_cap) {
  delete image_cap_;
  image_cap_ = image_cap;
  if (image_cap) {
    set_has_image_cap();
  } else {
    clear_has_image_cap();
  }
}

// required .hoolai.gui.model.Color tint_color = 3;
inline bool ImageView::has_tint_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageView::set_has_tint_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageView::clear_has_tint_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageView::clear_tint_color() {
  if (tint_color_ != NULL) tint_color_->::hoolai::gui::model::Color::Clear();
  clear_has_tint_color();
}
inline const ::hoolai::gui::model::Color& ImageView::tint_color() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tint_color_ != NULL ? *tint_color_ : *default_instance().tint_color_;
#else
  return tint_color_ != NULL ? *tint_color_ : *default_instance_->tint_color_;
#endif
}
inline ::hoolai::gui::model::Color* ImageView::mutable_tint_color() {
  set_has_tint_color();
  if (tint_color_ == NULL) tint_color_ = new ::hoolai::gui::model::Color;
  return tint_color_;
}
inline ::hoolai::gui::model::Color* ImageView::release_tint_color() {
  clear_has_tint_color();
  ::hoolai::gui::model::Color* temp = tint_color_;
  tint_color_ = NULL;
  return temp;
}
inline void ImageView::set_allocated_tint_color(::hoolai::gui::model::Color* tint_color) {
  delete tint_color_;
  tint_color_ = tint_color;
  if (tint_color) {
    set_has_tint_color();
  } else {
    clear_has_tint_color();
  }
}

// required bool gray = 4;
inline bool ImageView::has_gray() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageView::set_has_gray() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageView::clear_has_gray() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageView::clear_gray() {
  gray_ = false;
  clear_has_gray();
}
inline bool ImageView::gray() const {
  return gray_;
}
inline void ImageView::set_gray(bool value) {
  set_has_gray();
  gray_ = value;
}

// required bool repeat = 5;
inline bool ImageView::has_repeat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageView::set_has_repeat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageView::clear_has_repeat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageView::clear_repeat() {
  repeat_ = false;
  clear_has_repeat();
}
inline bool ImageView::repeat() const {
  return repeat_;
}
inline void ImageView::set_repeat(bool value) {
  set_has_repeat();
  repeat_ = value;
}

// required float brightness = 6;
inline bool ImageView::has_brightness() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageView::set_has_brightness() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageView::clear_has_brightness() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageView::clear_brightness() {
  brightness_ = 0;
  clear_has_brightness();
}
inline float ImageView::brightness() const {
  return brightness_;
}
inline void ImageView::set_brightness(float value) {
  set_has_brightness();
  brightness_ = value;
}

// required bool flip_x = 7;
inline bool ImageView::has_flip_x() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageView::set_has_flip_x() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageView::clear_has_flip_x() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageView::clear_flip_x() {
  flip_x_ = false;
  clear_has_flip_x();
}
inline bool ImageView::flip_x() const {
  return flip_x_;
}
inline void ImageView::set_flip_x(bool value) {
  set_has_flip_x();
  flip_x_ = value;
}

// required bool flip_y = 8;
inline bool ImageView::has_flip_y() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageView::set_has_flip_y() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageView::clear_has_flip_y() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageView::clear_flip_y() {
  flip_y_ = false;
  clear_has_flip_y();
}
inline bool ImageView::flip_y() const {
  return flip_y_;
}
inline void ImageView::set_flip_y(bool value) {
  set_has_flip_y();
  flip_y_ = value;
}

// optional string clip_image = 9;
inline bool ImageView::has_clip_image() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImageView::set_has_clip_image() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImageView::clear_has_clip_image() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImageView::clear_clip_image() {
  if (clip_image_ != &::google::protobuf::internal::kEmptyString) {
    clip_image_->clear();
  }
  clear_has_clip_image();
}
inline const ::std::string& ImageView::clip_image() const {
  return *clip_image_;
}
inline void ImageView::set_clip_image(const ::std::string& value) {
  set_has_clip_image();
  if (clip_image_ == &::google::protobuf::internal::kEmptyString) {
    clip_image_ = new ::std::string;
  }
  clip_image_->assign(value);
}
inline void ImageView::set_clip_image(const char* value) {
  set_has_clip_image();
  if (clip_image_ == &::google::protobuf::internal::kEmptyString) {
    clip_image_ = new ::std::string;
  }
  clip_image_->assign(value);
}
inline void ImageView::set_clip_image(const char* value, size_t size) {
  set_has_clip_image();
  if (clip_image_ == &::google::protobuf::internal::kEmptyString) {
    clip_image_ = new ::std::string;
  }
  clip_image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageView::mutable_clip_image() {
  set_has_clip_image();
  if (clip_image_ == &::google::protobuf::internal::kEmptyString) {
    clip_image_ = new ::std::string;
  }
  return clip_image_;
}
inline ::std::string* ImageView::release_clip_image() {
  clear_has_clip_image();
  if (clip_image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clip_image_;
    clip_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImageView::set_allocated_clip_image(::std::string* clip_image) {
  if (clip_image_ != &::google::protobuf::internal::kEmptyString) {
    delete clip_image_;
  }
  if (clip_image) {
    set_has_clip_image();
    clip_image_ = clip_image;
  } else {
    clear_has_clip_image();
    clip_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float rotation = 10;
inline bool ImageView::has_rotation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImageView::set_has_rotation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImageView::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImageView::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float ImageView::rotation() const {
  return rotation_;
}
inline void ImageView::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// -------------------------------------------------------------------

// Button_TitleNImage

// optional string title = 1;
inline bool Button_TitleNImage::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Button_TitleNImage::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Button_TitleNImage::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Button_TitleNImage::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Button_TitleNImage::title() const {
  return *title_;
}
inline void Button_TitleNImage::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Button_TitleNImage::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Button_TitleNImage::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button_TitleNImage::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* Button_TitleNImage::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button_TitleNImage::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string image = 2;
inline bool Button_TitleNImage::has_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Button_TitleNImage::set_has_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Button_TitleNImage::clear_has_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Button_TitleNImage::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& Button_TitleNImage::image() const {
  return *image_;
}
inline void Button_TitleNImage::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void Button_TitleNImage::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void Button_TitleNImage::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button_TitleNImage::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* Button_TitleNImage::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button_TitleNImage::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .hoolai.gui.model.Rect image_cap = 3;
inline bool Button_TitleNImage::has_image_cap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Button_TitleNImage::set_has_image_cap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Button_TitleNImage::clear_has_image_cap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Button_TitleNImage::clear_image_cap() {
  if (image_cap_ != NULL) image_cap_->::hoolai::gui::model::Rect::Clear();
  clear_has_image_cap();
}
inline const ::hoolai::gui::model::Rect& Button_TitleNImage::image_cap() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return image_cap_ != NULL ? *image_cap_ : *default_instance().image_cap_;
#else
  return image_cap_ != NULL ? *image_cap_ : *default_instance_->image_cap_;
#endif
}
inline ::hoolai::gui::model::Rect* Button_TitleNImage::mutable_image_cap() {
  set_has_image_cap();
  if (image_cap_ == NULL) image_cap_ = new ::hoolai::gui::model::Rect;
  return image_cap_;
}
inline ::hoolai::gui::model::Rect* Button_TitleNImage::release_image_cap() {
  clear_has_image_cap();
  ::hoolai::gui::model::Rect* temp = image_cap_;
  image_cap_ = NULL;
  return temp;
}
inline void Button_TitleNImage::set_allocated_image_cap(::hoolai::gui::model::Rect* image_cap) {
  delete image_cap_;
  image_cap_ = image_cap;
  if (image_cap) {
    set_has_image_cap();
  } else {
    clear_has_image_cap();
  }
}

// optional string clip_image = 4;
inline bool Button_TitleNImage::has_clip_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Button_TitleNImage::set_has_clip_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Button_TitleNImage::clear_has_clip_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Button_TitleNImage::clear_clip_image() {
  if (clip_image_ != &::google::protobuf::internal::kEmptyString) {
    clip_image_->clear();
  }
  clear_has_clip_image();
}
inline const ::std::string& Button_TitleNImage::clip_image() const {
  return *clip_image_;
}
inline void Button_TitleNImage::set_clip_image(const ::std::string& value) {
  set_has_clip_image();
  if (clip_image_ == &::google::protobuf::internal::kEmptyString) {
    clip_image_ = new ::std::string;
  }
  clip_image_->assign(value);
}
inline void Button_TitleNImage::set_clip_image(const char* value) {
  set_has_clip_image();
  if (clip_image_ == &::google::protobuf::internal::kEmptyString) {
    clip_image_ = new ::std::string;
  }
  clip_image_->assign(value);
}
inline void Button_TitleNImage::set_clip_image(const char* value, size_t size) {
  set_has_clip_image();
  if (clip_image_ == &::google::protobuf::internal::kEmptyString) {
    clip_image_ = new ::std::string;
  }
  clip_image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Button_TitleNImage::mutable_clip_image() {
  set_has_clip_image();
  if (clip_image_ == &::google::protobuf::internal::kEmptyString) {
    clip_image_ = new ::std::string;
  }
  return clip_image_;
}
inline ::std::string* Button_TitleNImage::release_clip_image() {
  clear_has_clip_image();
  if (clip_image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clip_image_;
    clip_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Button_TitleNImage::set_allocated_clip_image(::std::string* clip_image) {
  if (clip_image_ != &::google::protobuf::internal::kEmptyString) {
    delete clip_image_;
  }
  if (clip_image) {
    set_has_clip_image();
    clip_image_ = clip_image;
  } else {
    clear_has_clip_image();
    clip_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Button

// required .hoolai.gui.model.Label label = 1;
inline bool Button::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Button::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Button::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Button::clear_label() {
  if (label_ != NULL) label_->::hoolai::gui::model::Label::Clear();
  clear_has_label();
}
inline const ::hoolai::gui::model::Label& Button::label() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return label_ != NULL ? *label_ : *default_instance().label_;
#else
  return label_ != NULL ? *label_ : *default_instance_->label_;
#endif
}
inline ::hoolai::gui::model::Label* Button::mutable_label() {
  set_has_label();
  if (label_ == NULL) label_ = new ::hoolai::gui::model::Label;
  return label_;
}
inline ::hoolai::gui::model::Label* Button::release_label() {
  clear_has_label();
  ::hoolai::gui::model::Label* temp = label_;
  label_ = NULL;
  return temp;
}
inline void Button::set_allocated_label(::hoolai::gui::model::Label* label) {
  delete label_;
  label_ = label;
  if (label) {
    set_has_label();
  } else {
    clear_has_label();
  }
}

// required .hoolai.gui.model.Button.TitleNImage normal = 2;
inline bool Button::has_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Button::set_has_normal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Button::clear_has_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Button::clear_normal() {
  if (normal_ != NULL) normal_->::hoolai::gui::model::Button_TitleNImage::Clear();
  clear_has_normal();
}
inline const ::hoolai::gui::model::Button_TitleNImage& Button::normal() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return normal_ != NULL ? *normal_ : *default_instance().normal_;
#else
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
#endif
}
inline ::hoolai::gui::model::Button_TitleNImage* Button::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) normal_ = new ::hoolai::gui::model::Button_TitleNImage;
  return normal_;
}
inline ::hoolai::gui::model::Button_TitleNImage* Button::release_normal() {
  clear_has_normal();
  ::hoolai::gui::model::Button_TitleNImage* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void Button::set_allocated_normal(::hoolai::gui::model::Button_TitleNImage* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
}

// optional .hoolai.gui.model.Button.TitleNImage selected = 3;
inline bool Button::has_selected() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Button::set_has_selected() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Button::clear_has_selected() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Button::clear_selected() {
  if (selected_ != NULL) selected_->::hoolai::gui::model::Button_TitleNImage::Clear();
  clear_has_selected();
}
inline const ::hoolai::gui::model::Button_TitleNImage& Button::selected() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return selected_ != NULL ? *selected_ : *default_instance().selected_;
#else
  return selected_ != NULL ? *selected_ : *default_instance_->selected_;
#endif
}
inline ::hoolai::gui::model::Button_TitleNImage* Button::mutable_selected() {
  set_has_selected();
  if (selected_ == NULL) selected_ = new ::hoolai::gui::model::Button_TitleNImage;
  return selected_;
}
inline ::hoolai::gui::model::Button_TitleNImage* Button::release_selected() {
  clear_has_selected();
  ::hoolai::gui::model::Button_TitleNImage* temp = selected_;
  selected_ = NULL;
  return temp;
}
inline void Button::set_allocated_selected(::hoolai::gui::model::Button_TitleNImage* selected) {
  delete selected_;
  selected_ = selected;
  if (selected) {
    set_has_selected();
  } else {
    clear_has_selected();
  }
}

// optional .hoolai.gui.model.Button.TitleNImage highlighted = 4;
inline bool Button::has_highlighted() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Button::set_has_highlighted() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Button::clear_has_highlighted() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Button::clear_highlighted() {
  if (highlighted_ != NULL) highlighted_->::hoolai::gui::model::Button_TitleNImage::Clear();
  clear_has_highlighted();
}
inline const ::hoolai::gui::model::Button_TitleNImage& Button::highlighted() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return highlighted_ != NULL ? *highlighted_ : *default_instance().highlighted_;
#else
  return highlighted_ != NULL ? *highlighted_ : *default_instance_->highlighted_;
#endif
}
inline ::hoolai::gui::model::Button_TitleNImage* Button::mutable_highlighted() {
  set_has_highlighted();
  if (highlighted_ == NULL) highlighted_ = new ::hoolai::gui::model::Button_TitleNImage;
  return highlighted_;
}
inline ::hoolai::gui::model::Button_TitleNImage* Button::release_highlighted() {
  clear_has_highlighted();
  ::hoolai::gui::model::Button_TitleNImage* temp = highlighted_;
  highlighted_ = NULL;
  return temp;
}
inline void Button::set_allocated_highlighted(::hoolai::gui::model::Button_TitleNImage* highlighted) {
  delete highlighted_;
  highlighted_ = highlighted;
  if (highlighted) {
    set_has_highlighted();
  } else {
    clear_has_highlighted();
  }
}

// optional .hoolai.gui.model.Button.TitleNImage disabled = 5;
inline bool Button::has_disabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Button::set_has_disabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Button::clear_has_disabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Button::clear_disabled() {
  if (disabled_ != NULL) disabled_->::hoolai::gui::model::Button_TitleNImage::Clear();
  clear_has_disabled();
}
inline const ::hoolai::gui::model::Button_TitleNImage& Button::disabled() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return disabled_ != NULL ? *disabled_ : *default_instance().disabled_;
#else
  return disabled_ != NULL ? *disabled_ : *default_instance_->disabled_;
#endif
}
inline ::hoolai::gui::model::Button_TitleNImage* Button::mutable_disabled() {
  set_has_disabled();
  if (disabled_ == NULL) disabled_ = new ::hoolai::gui::model::Button_TitleNImage;
  return disabled_;
}
inline ::hoolai::gui::model::Button_TitleNImage* Button::release_disabled() {
  clear_has_disabled();
  ::hoolai::gui::model::Button_TitleNImage* temp = disabled_;
  disabled_ = NULL;
  return temp;
}
inline void Button::set_allocated_disabled(::hoolai::gui::model::Button_TitleNImage* disabled) {
  delete disabled_;
  disabled_ = disabled;
  if (disabled) {
    set_has_disabled();
  } else {
    clear_has_disabled();
  }
}

// required bool zoom_on_touchdown = 6;
inline bool Button::has_zoom_on_touchdown() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Button::set_has_zoom_on_touchdown() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Button::clear_has_zoom_on_touchdown() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Button::clear_zoom_on_touchdown() {
  zoom_on_touchdown_ = false;
  clear_has_zoom_on_touchdown();
}
inline bool Button::zoom_on_touchdown() const {
  return zoom_on_touchdown_;
}
inline void Button::set_zoom_on_touchdown(bool value) {
  set_has_zoom_on_touchdown();
  zoom_on_touchdown_ = value;
}

// required bool repeat = 7;
inline bool Button::has_repeat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Button::set_has_repeat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Button::clear_has_repeat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Button::clear_repeat() {
  repeat_ = false;
  clear_has_repeat();
}
inline bool Button::repeat() const {
  return repeat_;
}
inline void Button::set_repeat(bool value) {
  set_has_repeat();
  repeat_ = value;
}

// optional int32 state = 8;
inline bool Button::has_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Button::set_has_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Button::clear_has_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Button::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 Button::state() const {
  return state_;
}
inline void Button::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional int32 action = 9;
inline bool Button::has_action() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Button::set_has_action() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Button::clear_has_action() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Button::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 Button::action() const {
  return action_;
}
inline void Button::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// -------------------------------------------------------------------

// EditBox

// optional .hoolai.gui.model.Label label = 1;
inline bool EditBox::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EditBox::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EditBox::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EditBox::clear_label() {
  if (label_ != NULL) label_->::hoolai::gui::model::Label::Clear();
  clear_has_label();
}
inline const ::hoolai::gui::model::Label& EditBox::label() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return label_ != NULL ? *label_ : *default_instance().label_;
#else
  return label_ != NULL ? *label_ : *default_instance_->label_;
#endif
}
inline ::hoolai::gui::model::Label* EditBox::mutable_label() {
  set_has_label();
  if (label_ == NULL) label_ = new ::hoolai::gui::model::Label;
  return label_;
}
inline ::hoolai::gui::model::Label* EditBox::release_label() {
  clear_has_label();
  ::hoolai::gui::model::Label* temp = label_;
  label_ = NULL;
  return temp;
}
inline void EditBox::set_allocated_label(::hoolai::gui::model::Label* label) {
  delete label_;
  label_ = label;
  if (label) {
    set_has_label();
  } else {
    clear_has_label();
  }
}

// -------------------------------------------------------------------

// View

// optional int32 id = 1;
inline bool View::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void View::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void View::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void View::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 View::id() const {
  return id_;
}
inline void View::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string class_name = 2;
inline bool View::has_class_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void View::set_has_class_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void View::clear_has_class_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void View::clear_class_name() {
  if (class_name_ != &::google::protobuf::internal::kEmptyString) {
    class_name_->clear();
  }
  clear_has_class_name();
}
inline const ::std::string& View::class_name() const {
  return *class_name_;
}
inline void View::set_class_name(const ::std::string& value) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(value);
}
inline void View::set_class_name(const char* value) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(value);
}
inline void View::set_class_name(const char* value, size_t size) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* View::mutable_class_name() {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  return class_name_;
}
inline ::std::string* View::release_class_name() {
  clear_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = class_name_;
    class_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void View::set_allocated_class_name(::std::string* class_name) {
  if (class_name_ != &::google::protobuf::internal::kEmptyString) {
    delete class_name_;
  }
  if (class_name) {
    set_has_class_name();
    class_name_ = class_name;
  } else {
    clear_has_class_name();
    class_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .hoolai.gui.model.View.Type type = 3;
inline bool View::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void View::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void View::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void View::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::hoolai::gui::model::View_Type View::type() const {
  return static_cast< ::hoolai::gui::model::View_Type >(type_);
}
inline void View::set_type(::hoolai::gui::model::View_Type value) {
  assert(::hoolai::gui::model::View_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required float x = 4;
inline bool View::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void View::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void View::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void View::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float View::x() const {
  return x_;
}
inline void View::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 5;
inline bool View::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void View::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void View::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void View::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float View::y() const {
  return y_;
}
inline void View::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float width = 6;
inline bool View::has_width() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void View::set_has_width() {
  _has_bits_[0] |= 0x00000020u;
}
inline void View::clear_has_width() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void View::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float View::width() const {
  return width_;
}
inline void View::set_width(float value) {
  set_has_width();
  width_ = value;
}

// required float height = 7;
inline bool View::has_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void View::set_has_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void View::clear_has_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void View::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float View::height() const {
  return height_;
}
inline void View::set_height(float value) {
  set_has_height();
  height_ = value;
}

// optional .hoolai.gui.model.Color bg_color = 8;
inline bool View::has_bg_color() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void View::set_has_bg_color() {
  _has_bits_[0] |= 0x00000080u;
}
inline void View::clear_has_bg_color() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void View::clear_bg_color() {
  if (bg_color_ != NULL) bg_color_->::hoolai::gui::model::Color::Clear();
  clear_has_bg_color();
}
inline const ::hoolai::gui::model::Color& View::bg_color() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bg_color_ != NULL ? *bg_color_ : *default_instance().bg_color_;
#else
  return bg_color_ != NULL ? *bg_color_ : *default_instance_->bg_color_;
#endif
}
inline ::hoolai::gui::model::Color* View::mutable_bg_color() {
  set_has_bg_color();
  if (bg_color_ == NULL) bg_color_ = new ::hoolai::gui::model::Color;
  return bg_color_;
}
inline ::hoolai::gui::model::Color* View::release_bg_color() {
  clear_has_bg_color();
  ::hoolai::gui::model::Color* temp = bg_color_;
  bg_color_ = NULL;
  return temp;
}
inline void View::set_allocated_bg_color(::hoolai::gui::model::Color* bg_color) {
  delete bg_color_;
  bg_color_ = bg_color;
  if (bg_color) {
    set_has_bg_color();
  } else {
    clear_has_bg_color();
  }
}

// required bool visible = 9;
inline bool View::has_visible() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void View::set_has_visible() {
  _has_bits_[0] |= 0x00000100u;
}
inline void View::clear_has_visible() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void View::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool View::visible() const {
  return visible_;
}
inline void View::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional .hoolai.gui.model.Label label = 10;
inline bool View::has_label() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void View::set_has_label() {
  _has_bits_[0] |= 0x00000200u;
}
inline void View::clear_has_label() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void View::clear_label() {
  if (label_ != NULL) label_->::hoolai::gui::model::Label::Clear();
  clear_has_label();
}
inline const ::hoolai::gui::model::Label& View::label() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return label_ != NULL ? *label_ : *default_instance().label_;
#else
  return label_ != NULL ? *label_ : *default_instance_->label_;
#endif
}
inline ::hoolai::gui::model::Label* View::mutable_label() {
  set_has_label();
  if (label_ == NULL) label_ = new ::hoolai::gui::model::Label;
  return label_;
}
inline ::hoolai::gui::model::Label* View::release_label() {
  clear_has_label();
  ::hoolai::gui::model::Label* temp = label_;
  label_ = NULL;
  return temp;
}
inline void View::set_allocated_label(::hoolai::gui::model::Label* label) {
  delete label_;
  label_ = label;
  if (label) {
    set_has_label();
  } else {
    clear_has_label();
  }
}

// optional .hoolai.gui.model.ImageView image = 11;
inline bool View::has_image() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void View::set_has_image() {
  _has_bits_[0] |= 0x00000400u;
}
inline void View::clear_has_image() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void View::clear_image() {
  if (image_ != NULL) image_->::hoolai::gui::model::ImageView::Clear();
  clear_has_image();
}
inline const ::hoolai::gui::model::ImageView& View::image() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return image_ != NULL ? *image_ : *default_instance().image_;
#else
  return image_ != NULL ? *image_ : *default_instance_->image_;
#endif
}
inline ::hoolai::gui::model::ImageView* View::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::hoolai::gui::model::ImageView;
  return image_;
}
inline ::hoolai::gui::model::ImageView* View::release_image() {
  clear_has_image();
  ::hoolai::gui::model::ImageView* temp = image_;
  image_ = NULL;
  return temp;
}
inline void View::set_allocated_image(::hoolai::gui::model::ImageView* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
}

// optional .hoolai.gui.model.Button button = 12;
inline bool View::has_button() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void View::set_has_button() {
  _has_bits_[0] |= 0x00000800u;
}
inline void View::clear_has_button() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void View::clear_button() {
  if (button_ != NULL) button_->::hoolai::gui::model::Button::Clear();
  clear_has_button();
}
inline const ::hoolai::gui::model::Button& View::button() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return button_ != NULL ? *button_ : *default_instance().button_;
#else
  return button_ != NULL ? *button_ : *default_instance_->button_;
#endif
}
inline ::hoolai::gui::model::Button* View::mutable_button() {
  set_has_button();
  if (button_ == NULL) button_ = new ::hoolai::gui::model::Button;
  return button_;
}
inline ::hoolai::gui::model::Button* View::release_button() {
  clear_has_button();
  ::hoolai::gui::model::Button* temp = button_;
  button_ = NULL;
  return temp;
}
inline void View::set_allocated_button(::hoolai::gui::model::Button* button) {
  delete button_;
  button_ = button;
  if (button) {
    set_has_button();
  } else {
    clear_has_button();
  }
}

// repeated .hoolai.gui.model.View children = 13;
inline int View::children_size() const {
  return children_.size();
}
inline void View::clear_children() {
  children_.Clear();
}
inline const ::hoolai::gui::model::View& View::children(int index) const {
  return children_.Get(index);
}
inline ::hoolai::gui::model::View* View::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::hoolai::gui::model::View* View::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hoolai::gui::model::View >&
View::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::hoolai::gui::model::View >*
View::mutable_children() {
  return &children_;
}

// optional int32 tag = 14;
inline bool View::has_tag() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void View::set_has_tag() {
  _has_bits_[0] |= 0x00002000u;
}
inline void View::clear_has_tag() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void View::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 View::tag() const {
  return tag_;
}
inline void View::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional .hoolai.gui.model.EditBox editBox = 15;
inline bool View::has_editbox() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void View::set_has_editbox() {
  _has_bits_[0] |= 0x00004000u;
}
inline void View::clear_has_editbox() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void View::clear_editbox() {
  if (editbox_ != NULL) editbox_->::hoolai::gui::model::EditBox::Clear();
  clear_has_editbox();
}
inline const ::hoolai::gui::model::EditBox& View::editbox() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return editbox_ != NULL ? *editbox_ : *default_instance().editbox_;
#else
  return editbox_ != NULL ? *editbox_ : *default_instance_->editbox_;
#endif
}
inline ::hoolai::gui::model::EditBox* View::mutable_editbox() {
  set_has_editbox();
  if (editbox_ == NULL) editbox_ = new ::hoolai::gui::model::EditBox;
  return editbox_;
}
inline ::hoolai::gui::model::EditBox* View::release_editbox() {
  clear_has_editbox();
  ::hoolai::gui::model::EditBox* temp = editbox_;
  editbox_ = NULL;
  return temp;
}
inline void View::set_allocated_editbox(::hoolai::gui::model::EditBox* editbox) {
  delete editbox_;
  editbox_ = editbox;
  if (editbox) {
    set_has_editbox();
  } else {
    clear_has_editbox();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace model
}  // namespace gui
}  // namespace hoolai

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_guifile_2eproto__INCLUDED
