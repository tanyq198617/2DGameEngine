// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: guifile.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "guifile.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace hoolai {
namespace gui {
namespace model {

void protobuf_ShutdownFile_guifile_2eproto() {
  delete Color::default_instance_;
  delete Rect::default_instance_;
  delete Scrollview::default_instance_;
  delete Label::default_instance_;
  delete ImageView::default_instance_;
  delete Button::default_instance_;
  delete Button_TitleNImage::default_instance_;
  delete EditBox::default_instance_;
  delete View::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_guifile_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_guifile_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Color::default_instance_ = new Color();
  Rect::default_instance_ = new Rect();
  Scrollview::default_instance_ = new Scrollview();
  Label::default_instance_ = new Label();
  ImageView::default_instance_ = new ImageView();
  Button::default_instance_ = new Button();
  Button_TitleNImage::default_instance_ = new Button_TitleNImage();
  EditBox::default_instance_ = new EditBox();
  View::default_instance_ = new View();
  Color::default_instance_->InitAsDefaultInstance();
  Rect::default_instance_->InitAsDefaultInstance();
  Scrollview::default_instance_->InitAsDefaultInstance();
  Label::default_instance_->InitAsDefaultInstance();
  ImageView::default_instance_->InitAsDefaultInstance();
  Button::default_instance_->InitAsDefaultInstance();
  Button_TitleNImage::default_instance_->InitAsDefaultInstance();
  EditBox::default_instance_->InitAsDefaultInstance();
  View::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_guifile_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_guifile_2eproto_once_);
void protobuf_AddDesc_guifile_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_guifile_2eproto_once_,
                 &protobuf_AddDesc_guifile_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_guifile_2eproto {
  StaticDescriptorInitializer_guifile_2eproto() {
    protobuf_AddDesc_guifile_2eproto();
  }
} static_descriptor_initializer_guifile_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int Color::kRFieldNumber;
const int Color::kGFieldNumber;
const int Color::kBFieldNumber;
const int Color::kAFieldNumber;
#endif  // !_MSC_VER

Color::Color()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Color::InitAsDefaultInstance() {
}

Color::Color(const Color& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Color::SharedCtor() {
  _cached_size_ = 0;
  r_ = 0;
  g_ = 0;
  b_ = 0;
  a_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Color::~Color() {
  SharedDtor();
}

void Color::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Color::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Color& Color::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_guifile_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_guifile_2eproto();
#endif
  return *default_instance_;
}

Color* Color::default_instance_ = NULL;

Color* Color::New() const {
  return new Color;
}

void Color::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    r_ = 0;
    g_ = 0;
    b_ = 0;
    a_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Color::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 r = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &r_)));
          set_has_r();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_g;
        break;
      }

      // required int32 g = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_g:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &g_)));
          set_has_g();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_b;
        break;
      }

      // required int32 b = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_b:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &b_)));
          set_has_b();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_a;
        break;
      }

      // required int32 a = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_a:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &a_)));
          set_has_a();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Color::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 r = 1;
  if (has_r()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->r(), output);
  }

  // required int32 g = 2;
  if (has_g()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->g(), output);
  }

  // required int32 b = 3;
  if (has_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->b(), output);
  }

  // required int32 a = 4;
  if (has_a()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->a(), output);
  }

}

int Color::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 r = 1;
    if (has_r()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->r());
    }

    // required int32 g = 2;
    if (has_g()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->g());
    }

    // required int32 b = 3;
    if (has_b()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->b());
    }

    // required int32 a = 4;
    if (has_a()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->a());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Color::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Color*>(&from));
}

void Color::MergeFrom(const Color& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_r()) {
      set_r(from.r());
    }
    if (from.has_g()) {
      set_g(from.g());
    }
    if (from.has_b()) {
      set_b(from.b());
    }
    if (from.has_a()) {
      set_a(from.a());
    }
  }
}

void Color::CopyFrom(const Color& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Color::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Color::Swap(Color* other) {
  if (other != this) {
    std::swap(r_, other->r_);
    std::swap(g_, other->g_);
    std::swap(b_, other->b_);
    std::swap(a_, other->a_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Color::GetTypeName() const {
  return "hoolai.gui.model.Color";
}


void Color::printDebugInfo() const 
{
#ifdef DEBUG
  printf("Color\n");
  printf("{\n");
  printf("r : %d\n", r());
  printf("g : %d\n", g());
  printf("b : %d\n", b());
  printf("a : %d\n", a());
  printf("}\n");
#endif
}

// ===================================================================

#ifndef _MSC_VER
const int Rect::kXFieldNumber;
const int Rect::kYFieldNumber;
const int Rect::kWidthFieldNumber;
const int Rect::kHeightFieldNumber;
#endif  // !_MSC_VER

Rect::Rect()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Rect::InitAsDefaultInstance() {
}

Rect::Rect(const Rect& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Rect::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  width_ = 0;
  height_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Rect::~Rect() {
  SharedDtor();
}

void Rect::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Rect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Rect& Rect::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_guifile_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_guifile_2eproto();
#endif
  return *default_instance_;
}

Rect* Rect::default_instance_ = NULL;

Rect* Rect::New() const {
  return new Rect;
}

void Rect::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    width_ = 0;
    height_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Rect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_width;
        break;
      }

      // required float width = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_height;
        break;
      }

      // required float height = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Rect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float width = 3;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->width(), output);
  }

  // required float height = 4;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->height(), output);
  }

}

int Rect::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float width = 3;
    if (has_width()) {
      total_size += 1 + 4;
    }

    // required float height = 4;
    if (has_height()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Rect::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Rect*>(&from));
}

void Rect::MergeFrom(const Rect& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
  }
}

void Rect::CopyFrom(const Rect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rect::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Rect::Swap(Rect* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Rect::GetTypeName() const {
  return "hoolai.gui.model.Rect";
}


void Rect::printDebugInfo() const 
{
#ifdef DEBUG
  printf("Rect\n");
  printf("{\n");
  printf("x : %f\n", x());
  printf("y : %f\n", y());
  printf("width : %f\n", width());
  printf("height : %f\n", height());
  printf("}\n");
#endif
}

// ===================================================================

#ifndef _MSC_VER
const int Scrollview::kViewFieldNumber;
#endif  // !_MSC_VER

Scrollview::Scrollview()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Scrollview::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  view_ = const_cast< ::hoolai::gui::model::View*>(
      ::hoolai::gui::model::View::internal_default_instance());
#else
  view_ = const_cast< ::hoolai::gui::model::View*>(&::hoolai::gui::model::View::default_instance());
#endif
}

Scrollview::Scrollview(const Scrollview& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Scrollview::SharedCtor() {
  _cached_size_ = 0;
  view_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Scrollview::~Scrollview() {
  SharedDtor();
}

void Scrollview::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete view_;
  }
}

void Scrollview::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Scrollview& Scrollview::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_guifile_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_guifile_2eproto();
#endif
  return *default_instance_;
}

Scrollview* Scrollview::default_instance_ = NULL;

Scrollview* Scrollview::New() const {
  return new Scrollview;
}

void Scrollview::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_view()) {
      if (view_ != NULL) view_->::hoolai::gui::model::View::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Scrollview::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hoolai.gui.model.View view = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_view()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Scrollview::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hoolai.gui.model.View view = 1;
  if (has_view()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->view(), output);
  }

}

int Scrollview::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hoolai.gui.model.View view = 1;
    if (has_view()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->view());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Scrollview::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Scrollview*>(&from));
}

void Scrollview::MergeFrom(const Scrollview& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_view()) {
      mutable_view()->::hoolai::gui::model::View::MergeFrom(from.view());
    }
  }
}

void Scrollview::CopyFrom(const Scrollview& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Scrollview::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_view()) {
    if (!this->view().IsInitialized()) return false;
  }
  return true;
}

void Scrollview::Swap(Scrollview* other) {
  if (other != this) {
    std::swap(view_, other->view_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Scrollview::GetTypeName() const {
  return "hoolai.gui.model.Scrollview";
}


void Scrollview::printDebugInfo() const 
{
#ifdef DEBUG
  printf("Scrollview\n");
  printf("{\n");
  printf("view : \n");
  view().printDebugInfo();
  printf("}\n");
#endif
}

// ===================================================================

#ifndef _MSC_VER
const int Label::kTextFieldNumber;
const int Label::kFontSizeFieldNumber;
const int Label::kTlColorFieldNumber;
const int Label::kTrColorFieldNumber;
const int Label::kBlColorFieldNumber;
const int Label::kBrColorFieldNumber;
const int Label::kStrokeFieldNumber;
const int Label::kBoldFieldNumber;
const int Label::kStrokeColorFieldNumber;
const int Label::kTextAlignFieldNumber;
#endif  // !_MSC_VER

Label::Label()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Label::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tl_color_ = const_cast< ::hoolai::gui::model::Color*>(
      ::hoolai::gui::model::Color::internal_default_instance());
#else
  tl_color_ = const_cast< ::hoolai::gui::model::Color*>(&::hoolai::gui::model::Color::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tr_color_ = const_cast< ::hoolai::gui::model::Color*>(
      ::hoolai::gui::model::Color::internal_default_instance());
#else
  tr_color_ = const_cast< ::hoolai::gui::model::Color*>(&::hoolai::gui::model::Color::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bl_color_ = const_cast< ::hoolai::gui::model::Color*>(
      ::hoolai::gui::model::Color::internal_default_instance());
#else
  bl_color_ = const_cast< ::hoolai::gui::model::Color*>(&::hoolai::gui::model::Color::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  br_color_ = const_cast< ::hoolai::gui::model::Color*>(
      ::hoolai::gui::model::Color::internal_default_instance());
#else
  br_color_ = const_cast< ::hoolai::gui::model::Color*>(&::hoolai::gui::model::Color::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  stroke_color_ = const_cast< ::hoolai::gui::model::Color*>(
      ::hoolai::gui::model::Color::internal_default_instance());
#else
  stroke_color_ = const_cast< ::hoolai::gui::model::Color*>(&::hoolai::gui::model::Color::default_instance());
#endif
}

Label::Label(const Label& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Label::SharedCtor() {
  _cached_size_ = 0;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  font_size_ = 0;
  tl_color_ = NULL;
  tr_color_ = NULL;
  bl_color_ = NULL;
  br_color_ = NULL;
  stroke_ = false;
  bold_ = false;
  stroke_color_ = NULL;
  text_align_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Label::~Label() {
  SharedDtor();
}

void Label::SharedDtor() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tl_color_;
    delete tr_color_;
    delete bl_color_;
    delete br_color_;
    delete stroke_color_;
  }
}

void Label::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Label& Label::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_guifile_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_guifile_2eproto();
#endif
  return *default_instance_;
}

Label* Label::default_instance_ = NULL;

Label* Label::New() const {
  return new Label;
}

void Label::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
    font_size_ = 0;
    if (has_tl_color()) {
      if (tl_color_ != NULL) tl_color_->::hoolai::gui::model::Color::Clear();
    }
    if (has_tr_color()) {
      if (tr_color_ != NULL) tr_color_->::hoolai::gui::model::Color::Clear();
    }
    if (has_bl_color()) {
      if (bl_color_ != NULL) bl_color_->::hoolai::gui::model::Color::Clear();
    }
    if (has_br_color()) {
      if (br_color_ != NULL) br_color_->::hoolai::gui::model::Color::Clear();
    }
    stroke_ = false;
    bold_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_stroke_color()) {
      if (stroke_color_ != NULL) stroke_color_->::hoolai::gui::model::Color::Clear();
    }
    text_align_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Label::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string text = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_font_size;
        break;
      }

      // required int32 font_size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_font_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &font_size_)));
          set_has_font_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tl_color;
        break;
      }

      // required .hoolai.gui.model.Color tl_color = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tl_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tl_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_tr_color;
        break;
      }

      // required .hoolai.gui.model.Color tr_color = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tr_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tr_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_bl_color;
        break;
      }

      // required .hoolai.gui.model.Color bl_color = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bl_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bl_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_br_color;
        break;
      }

      // required .hoolai.gui.model.Color br_color = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_br_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_br_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_stroke;
        break;
      }

      // required bool stroke = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stroke:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &stroke_)));
          set_has_stroke();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_bold;
        break;
      }

      // required bool bold = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bold_)));
          set_has_bold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_stroke_color;
        break;
      }

      // required .hoolai.gui.model.Color stroke_color = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_stroke_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stroke_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_text_align;
        break;
      }

      // required int32 text_align = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_text_align:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &text_align_)));
          set_has_text_align();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Label::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string text = 1;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->text(), output);
  }

  // required int32 font_size = 2;
  if (has_font_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->font_size(), output);
  }

  // required .hoolai.gui.model.Color tl_color = 3;
  if (has_tl_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->tl_color(), output);
  }

  // required .hoolai.gui.model.Color tr_color = 4;
  if (has_tr_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->tr_color(), output);
  }

  // required .hoolai.gui.model.Color bl_color = 5;
  if (has_bl_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->bl_color(), output);
  }

  // required .hoolai.gui.model.Color br_color = 6;
  if (has_br_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->br_color(), output);
  }

  // required bool stroke = 7;
  if (has_stroke()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->stroke(), output);
  }

  // required bool bold = 8;
  if (has_bold()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->bold(), output);
  }

  // required .hoolai.gui.model.Color stroke_color = 9;
  if (has_stroke_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->stroke_color(), output);
  }

  // required int32 text_align = 10;
  if (has_text_align()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->text_align(), output);
  }

}

int Label::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string text = 1;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

    // required int32 font_size = 2;
    if (has_font_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->font_size());
    }

    // required .hoolai.gui.model.Color tl_color = 3;
    if (has_tl_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tl_color());
    }

    // required .hoolai.gui.model.Color tr_color = 4;
    if (has_tr_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tr_color());
    }

    // required .hoolai.gui.model.Color bl_color = 5;
    if (has_bl_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bl_color());
    }

    // required .hoolai.gui.model.Color br_color = 6;
    if (has_br_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->br_color());
    }

    // required bool stroke = 7;
    if (has_stroke()) {
      total_size += 1 + 1;
    }

    // required bool bold = 8;
    if (has_bold()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required .hoolai.gui.model.Color stroke_color = 9;
    if (has_stroke_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stroke_color());
    }

    // required int32 text_align = 10;
    if (has_text_align()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->text_align());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Label::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Label*>(&from));
}

void Label::MergeFrom(const Label& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_text()) {
      set_text(from.text());
    }
    if (from.has_font_size()) {
      set_font_size(from.font_size());
    }
    if (from.has_tl_color()) {
      mutable_tl_color()->::hoolai::gui::model::Color::MergeFrom(from.tl_color());
    }
    if (from.has_tr_color()) {
      mutable_tr_color()->::hoolai::gui::model::Color::MergeFrom(from.tr_color());
    }
    if (from.has_bl_color()) {
      mutable_bl_color()->::hoolai::gui::model::Color::MergeFrom(from.bl_color());
    }
    if (from.has_br_color()) {
      mutable_br_color()->::hoolai::gui::model::Color::MergeFrom(from.br_color());
    }
    if (from.has_stroke()) {
      set_stroke(from.stroke());
    }
    if (from.has_bold()) {
      set_bold(from.bold());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_stroke_color()) {
      mutable_stroke_color()->::hoolai::gui::model::Color::MergeFrom(from.stroke_color());
    }
    if (from.has_text_align()) {
      set_text_align(from.text_align());
    }
  }
}

void Label::CopyFrom(const Label& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Label::IsInitialized() const {
  if ((_has_bits_[0] & 0x000003fe) != 0x000003fe) return false;

  if (has_tl_color()) {
    if (!this->tl_color().IsInitialized()) return false;
  }
  if (has_tr_color()) {
    if (!this->tr_color().IsInitialized()) return false;
  }
  if (has_bl_color()) {
    if (!this->bl_color().IsInitialized()) return false;
  }
  if (has_br_color()) {
    if (!this->br_color().IsInitialized()) return false;
  }
  if (has_stroke_color()) {
    if (!this->stroke_color().IsInitialized()) return false;
  }
  return true;
}

void Label::Swap(Label* other) {
  if (other != this) {
    std::swap(text_, other->text_);
    std::swap(font_size_, other->font_size_);
    std::swap(tl_color_, other->tl_color_);
    std::swap(tr_color_, other->tr_color_);
    std::swap(bl_color_, other->bl_color_);
    std::swap(br_color_, other->br_color_);
    std::swap(stroke_, other->stroke_);
    std::swap(bold_, other->bold_);
    std::swap(stroke_color_, other->stroke_color_);
    std::swap(text_align_, other->text_align_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Label::GetTypeName() const {
  return "hoolai.gui.model.Label";
}


void Label::printDebugInfo() const 
{
#ifdef DEBUG
  printf("Label\n");
  printf("{\n");
  printf("text : %s\n", text().c_str());
  printf("font_size : %d\n", font_size());
  printf("tl_color : \n");
  tl_color().printDebugInfo();
  printf("tr_color : \n");
  tr_color().printDebugInfo();
  printf("bl_color : \n");
  bl_color().printDebugInfo();
  printf("br_color : \n");
  br_color().printDebugInfo();
  printf("stroke : %d\n", stroke());
  printf("bold : %d\n", bold());
  printf("stroke_color : \n");
  stroke_color().printDebugInfo();
  printf("text_align : %d\n", text_align());
  printf("}\n");
#endif
}

// ===================================================================

#ifndef _MSC_VER
const int ImageView::kImageFieldNumber;
const int ImageView::kImageCapFieldNumber;
const int ImageView::kTintColorFieldNumber;
const int ImageView::kGrayFieldNumber;
const int ImageView::kRepeatFieldNumber;
const int ImageView::kBrightnessFieldNumber;
const int ImageView::kFlipXFieldNumber;
const int ImageView::kFlipYFieldNumber;
const int ImageView::kClipImageFieldNumber;
const int ImageView::kRotationFieldNumber;
#endif  // !_MSC_VER

ImageView::ImageView()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ImageView::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  image_cap_ = const_cast< ::hoolai::gui::model::Rect*>(
      ::hoolai::gui::model::Rect::internal_default_instance());
#else
  image_cap_ = const_cast< ::hoolai::gui::model::Rect*>(&::hoolai::gui::model::Rect::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tint_color_ = const_cast< ::hoolai::gui::model::Color*>(
      ::hoolai::gui::model::Color::internal_default_instance());
#else
  tint_color_ = const_cast< ::hoolai::gui::model::Color*>(&::hoolai::gui::model::Color::default_instance());
#endif
}

ImageView::ImageView(const ImageView& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ImageView::SharedCtor() {
  _cached_size_ = 0;
  image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  image_cap_ = NULL;
  tint_color_ = NULL;
  gray_ = false;
  repeat_ = false;
  brightness_ = 0;
  flip_x_ = false;
  flip_y_ = false;
  clip_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  rotation_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImageView::~ImageView() {
  SharedDtor();
}

void ImageView::SharedDtor() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (clip_image_ != &::google::protobuf::internal::kEmptyString) {
    delete clip_image_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete image_cap_;
    delete tint_color_;
  }
}

void ImageView::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ImageView& ImageView::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_guifile_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_guifile_2eproto();
#endif
  return *default_instance_;
}

ImageView* ImageView::default_instance_ = NULL;

ImageView* ImageView::New() const {
  return new ImageView;
}

void ImageView::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_image()) {
      if (image_ != &::google::protobuf::internal::kEmptyString) {
        image_->clear();
      }
    }
    if (has_image_cap()) {
      if (image_cap_ != NULL) image_cap_->::hoolai::gui::model::Rect::Clear();
    }
    if (has_tint_color()) {
      if (tint_color_ != NULL) tint_color_->::hoolai::gui::model::Color::Clear();
    }
    gray_ = false;
    repeat_ = false;
    brightness_ = 0;
    flip_x_ = false;
    flip_y_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_clip_image()) {
      if (clip_image_ != &::google::protobuf::internal::kEmptyString) {
        clip_image_->clear();
      }
    }
    rotation_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ImageView::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string image = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_image()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_image_cap;
        break;
      }

      // required .hoolai.gui.model.Rect image_cap = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image_cap:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image_cap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tint_color;
        break;
      }

      // required .hoolai.gui.model.Color tint_color = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tint_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tint_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_gray;
        break;
      }

      // required bool gray = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gray:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &gray_)));
          set_has_gray();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_repeat;
        break;
      }

      // required bool repeat = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_repeat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &repeat_)));
          set_has_repeat();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_brightness;
        break;
      }

      // required float brightness = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_brightness:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &brightness_)));
          set_has_brightness();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_flip_x;
        break;
      }

      // required bool flip_x = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flip_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flip_x_)));
          set_has_flip_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_flip_y;
        break;
      }

      // required bool flip_y = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flip_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flip_y_)));
          set_has_flip_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_clip_image;
        break;
      }

      // optional string clip_image = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clip_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clip_image()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_rotation;
        break;
      }

      // optional float rotation = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rotation_)));
          set_has_rotation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImageView::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string image = 1;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->image(), output);
  }

  // required .hoolai.gui.model.Rect image_cap = 2;
  if (has_image_cap()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->image_cap(), output);
  }

  // required .hoolai.gui.model.Color tint_color = 3;
  if (has_tint_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->tint_color(), output);
  }

  // required bool gray = 4;
  if (has_gray()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->gray(), output);
  }

  // required bool repeat = 5;
  if (has_repeat()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->repeat(), output);
  }

  // required float brightness = 6;
  if (has_brightness()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->brightness(), output);
  }

  // required bool flip_x = 7;
  if (has_flip_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->flip_x(), output);
  }

  // required bool flip_y = 8;
  if (has_flip_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->flip_y(), output);
  }

  // optional string clip_image = 9;
  if (has_clip_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->clip_image(), output);
  }

  // optional float rotation = 10;
  if (has_rotation()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->rotation(), output);
  }

}

int ImageView::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string image = 1;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->image());
    }

    // required .hoolai.gui.model.Rect image_cap = 2;
    if (has_image_cap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->image_cap());
    }

    // required .hoolai.gui.model.Color tint_color = 3;
    if (has_tint_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tint_color());
    }

    // required bool gray = 4;
    if (has_gray()) {
      total_size += 1 + 1;
    }

    // required bool repeat = 5;
    if (has_repeat()) {
      total_size += 1 + 1;
    }

    // required float brightness = 6;
    if (has_brightness()) {
      total_size += 1 + 4;
    }

    // required bool flip_x = 7;
    if (has_flip_x()) {
      total_size += 1 + 1;
    }

    // required bool flip_y = 8;
    if (has_flip_y()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string clip_image = 9;
    if (has_clip_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clip_image());
    }

    // optional float rotation = 10;
    if (has_rotation()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageView::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ImageView*>(&from));
}

void ImageView::MergeFrom(const ImageView& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_image()) {
      set_image(from.image());
    }
    if (from.has_image_cap()) {
      mutable_image_cap()->::hoolai::gui::model::Rect::MergeFrom(from.image_cap());
    }
    if (from.has_tint_color()) {
      mutable_tint_color()->::hoolai::gui::model::Color::MergeFrom(from.tint_color());
    }
    if (from.has_gray()) {
      set_gray(from.gray());
    }
    if (from.has_repeat()) {
      set_repeat(from.repeat());
    }
    if (from.has_brightness()) {
      set_brightness(from.brightness());
    }
    if (from.has_flip_x()) {
      set_flip_x(from.flip_x());
    }
    if (from.has_flip_y()) {
      set_flip_y(from.flip_y());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_clip_image()) {
      set_clip_image(from.clip_image());
    }
    if (from.has_rotation()) {
      set_rotation(from.rotation());
    }
  }
}

void ImageView::CopyFrom(const ImageView& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageView::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_image_cap()) {
    if (!this->image_cap().IsInitialized()) return false;
  }
  if (has_tint_color()) {
    if (!this->tint_color().IsInitialized()) return false;
  }
  return true;
}

void ImageView::Swap(ImageView* other) {
  if (other != this) {
    std::swap(image_, other->image_);
    std::swap(image_cap_, other->image_cap_);
    std::swap(tint_color_, other->tint_color_);
    std::swap(gray_, other->gray_);
    std::swap(repeat_, other->repeat_);
    std::swap(brightness_, other->brightness_);
    std::swap(flip_x_, other->flip_x_);
    std::swap(flip_y_, other->flip_y_);
    std::swap(clip_image_, other->clip_image_);
    std::swap(rotation_, other->rotation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ImageView::GetTypeName() const {
  return "hoolai.gui.model.ImageView";
}


void ImageView::printDebugInfo() const 
{
#ifdef DEBUG
  printf("ImageView\n");
  printf("{\n");
  printf("image : %s\n", image().c_str());
  printf("image_cap : \n");
  image_cap().printDebugInfo();
  printf("tint_color : \n");
  tint_color().printDebugInfo();
  printf("gray : %d\n", gray());
  printf("repeat : %d\n", repeat());
  printf("brightness : %f\n", brightness());
  printf("flip_x : %d\n", flip_x());
  printf("flip_y : %d\n", flip_y());
  printf("clip_image : %s\n", clip_image().c_str());
  printf("rotation : %f\n", rotation());
  printf("}\n");
#endif
}

// ===================================================================

#ifndef _MSC_VER
const int Button_TitleNImage::kTitleFieldNumber;
const int Button_TitleNImage::kImageFieldNumber;
const int Button_TitleNImage::kImageCapFieldNumber;
const int Button_TitleNImage::kClipImageFieldNumber;
#endif  // !_MSC_VER

Button_TitleNImage::Button_TitleNImage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Button_TitleNImage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  image_cap_ = const_cast< ::hoolai::gui::model::Rect*>(
      ::hoolai::gui::model::Rect::internal_default_instance());
#else
  image_cap_ = const_cast< ::hoolai::gui::model::Rect*>(&::hoolai::gui::model::Rect::default_instance());
#endif
}

Button_TitleNImage::Button_TitleNImage(const Button_TitleNImage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Button_TitleNImage::SharedCtor() {
  _cached_size_ = 0;
  title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  image_cap_ = NULL;
  clip_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Button_TitleNImage::~Button_TitleNImage() {
  SharedDtor();
}

void Button_TitleNImage::SharedDtor() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (clip_image_ != &::google::protobuf::internal::kEmptyString) {
    delete clip_image_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete image_cap_;
  }
}

void Button_TitleNImage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Button_TitleNImage& Button_TitleNImage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_guifile_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_guifile_2eproto();
#endif
  return *default_instance_;
}

Button_TitleNImage* Button_TitleNImage::default_instance_ = NULL;

Button_TitleNImage* Button_TitleNImage::New() const {
  return new Button_TitleNImage;
}

void Button_TitleNImage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_title()) {
      if (title_ != &::google::protobuf::internal::kEmptyString) {
        title_->clear();
      }
    }
    if (has_image()) {
      if (image_ != &::google::protobuf::internal::kEmptyString) {
        image_->clear();
      }
    }
    if (has_image_cap()) {
      if (image_cap_ != NULL) image_cap_->::hoolai::gui::model::Rect::Clear();
    }
    if (has_clip_image()) {
      if (clip_image_ != &::google::protobuf::internal::kEmptyString) {
        clip_image_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Button_TitleNImage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string title = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_title()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_image;
        break;
      }

      // optional string image = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_image()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_image_cap;
        break;
      }

      // optional .hoolai.gui.model.Rect image_cap = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image_cap:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image_cap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_clip_image;
        break;
      }

      // optional string clip_image = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clip_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clip_image()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Button_TitleNImage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string title = 1;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->title(), output);
  }

  // optional string image = 2;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->image(), output);
  }

  // optional .hoolai.gui.model.Rect image_cap = 3;
  if (has_image_cap()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->image_cap(), output);
  }

  // optional string clip_image = 4;
  if (has_clip_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->clip_image(), output);
  }

}

int Button_TitleNImage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string title = 1;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->title());
    }

    // optional string image = 2;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->image());
    }

    // optional .hoolai.gui.model.Rect image_cap = 3;
    if (has_image_cap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->image_cap());
    }

    // optional string clip_image = 4;
    if (has_clip_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clip_image());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Button_TitleNImage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Button_TitleNImage*>(&from));
}

void Button_TitleNImage::MergeFrom(const Button_TitleNImage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_image()) {
      set_image(from.image());
    }
    if (from.has_image_cap()) {
      mutable_image_cap()->::hoolai::gui::model::Rect::MergeFrom(from.image_cap());
    }
    if (from.has_clip_image()) {
      set_clip_image(from.clip_image());
    }
  }
}

void Button_TitleNImage::CopyFrom(const Button_TitleNImage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Button_TitleNImage::IsInitialized() const {

  if (has_image_cap()) {
    if (!this->image_cap().IsInitialized()) return false;
  }
  return true;
}

void Button_TitleNImage::Swap(Button_TitleNImage* other) {
  if (other != this) {
    std::swap(title_, other->title_);
    std::swap(image_, other->image_);
    std::swap(image_cap_, other->image_cap_);
    std::swap(clip_image_, other->clip_image_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Button_TitleNImage::GetTypeName() const {
  return "hoolai.gui.model.Button.TitleNImage";
}


void Button_TitleNImage::printDebugInfo() const 
{
#ifdef DEBUG
  printf("Button_TitleNImage\n");
  printf("{\n");
  printf("title : %s\n", title().c_str());
  printf("image : %s\n", image().c_str());
  printf("image_cap : \n");
  image_cap().printDebugInfo();
  printf("clip_image : %s\n", clip_image().c_str());
  printf("}\n");
#endif
}

// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Button::kLabelFieldNumber;
const int Button::kNormalFieldNumber;
const int Button::kSelectedFieldNumber;
const int Button::kHighlightedFieldNumber;
const int Button::kDisabledFieldNumber;
const int Button::kZoomOnTouchdownFieldNumber;
const int Button::kRepeatFieldNumber;
const int Button::kStateFieldNumber;
const int Button::kActionFieldNumber;
#endif  // !_MSC_VER

Button::Button()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Button::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  label_ = const_cast< ::hoolai::gui::model::Label*>(
      ::hoolai::gui::model::Label::internal_default_instance());
#else
  label_ = const_cast< ::hoolai::gui::model::Label*>(&::hoolai::gui::model::Label::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  normal_ = const_cast< ::hoolai::gui::model::Button_TitleNImage*>(
      ::hoolai::gui::model::Button_TitleNImage::internal_default_instance());
#else
  normal_ = const_cast< ::hoolai::gui::model::Button_TitleNImage*>(&::hoolai::gui::model::Button_TitleNImage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  selected_ = const_cast< ::hoolai::gui::model::Button_TitleNImage*>(
      ::hoolai::gui::model::Button_TitleNImage::internal_default_instance());
#else
  selected_ = const_cast< ::hoolai::gui::model::Button_TitleNImage*>(&::hoolai::gui::model::Button_TitleNImage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  highlighted_ = const_cast< ::hoolai::gui::model::Button_TitleNImage*>(
      ::hoolai::gui::model::Button_TitleNImage::internal_default_instance());
#else
  highlighted_ = const_cast< ::hoolai::gui::model::Button_TitleNImage*>(&::hoolai::gui::model::Button_TitleNImage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  disabled_ = const_cast< ::hoolai::gui::model::Button_TitleNImage*>(
      ::hoolai::gui::model::Button_TitleNImage::internal_default_instance());
#else
  disabled_ = const_cast< ::hoolai::gui::model::Button_TitleNImage*>(&::hoolai::gui::model::Button_TitleNImage::default_instance());
#endif
}

Button::Button(const Button& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Button::SharedCtor() {
  _cached_size_ = 0;
  label_ = NULL;
  normal_ = NULL;
  selected_ = NULL;
  highlighted_ = NULL;
  disabled_ = NULL;
  zoom_on_touchdown_ = false;
  repeat_ = false;
  state_ = 0;
  action_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Button::~Button() {
  SharedDtor();
}

void Button::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete label_;
    delete normal_;
    delete selected_;
    delete highlighted_;
    delete disabled_;
  }
}

void Button::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Button& Button::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_guifile_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_guifile_2eproto();
#endif
  return *default_instance_;
}

Button* Button::default_instance_ = NULL;

Button* Button::New() const {
  return new Button;
}

void Button::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_label()) {
      if (label_ != NULL) label_->::hoolai::gui::model::Label::Clear();
    }
    if (has_normal()) {
      if (normal_ != NULL) normal_->::hoolai::gui::model::Button_TitleNImage::Clear();
    }
    if (has_selected()) {
      if (selected_ != NULL) selected_->::hoolai::gui::model::Button_TitleNImage::Clear();
    }
    if (has_highlighted()) {
      if (highlighted_ != NULL) highlighted_->::hoolai::gui::model::Button_TitleNImage::Clear();
    }
    if (has_disabled()) {
      if (disabled_ != NULL) disabled_->::hoolai::gui::model::Button_TitleNImage::Clear();
    }
    zoom_on_touchdown_ = false;
    repeat_ = false;
    state_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    action_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Button::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hoolai.gui.model.Label label = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_normal;
        break;
      }

      // required .hoolai.gui.model.Button.TitleNImage normal = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_normal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_normal()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_selected;
        break;
      }

      // optional .hoolai.gui.model.Button.TitleNImage selected = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_selected:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_selected()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_highlighted;
        break;
      }

      // optional .hoolai.gui.model.Button.TitleNImage highlighted = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_highlighted:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_highlighted()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_disabled;
        break;
      }

      // optional .hoolai.gui.model.Button.TitleNImage disabled = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_disabled:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_disabled()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_zoom_on_touchdown;
        break;
      }

      // required bool zoom_on_touchdown = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_zoom_on_touchdown:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &zoom_on_touchdown_)));
          set_has_zoom_on_touchdown();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_repeat;
        break;
      }

      // required bool repeat = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_repeat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &repeat_)));
          set_has_repeat();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_state;
        break;
      }

      // optional int32 state = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_action;
        break;
      }

      // optional int32 action = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_action:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &action_)));
          set_has_action();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Button::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hoolai.gui.model.Label label = 1;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->label(), output);
  }

  // required .hoolai.gui.model.Button.TitleNImage normal = 2;
  if (has_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->normal(), output);
  }

  // optional .hoolai.gui.model.Button.TitleNImage selected = 3;
  if (has_selected()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->selected(), output);
  }

  // optional .hoolai.gui.model.Button.TitleNImage highlighted = 4;
  if (has_highlighted()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->highlighted(), output);
  }

  // optional .hoolai.gui.model.Button.TitleNImage disabled = 5;
  if (has_disabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->disabled(), output);
  }

  // required bool zoom_on_touchdown = 6;
  if (has_zoom_on_touchdown()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->zoom_on_touchdown(), output);
  }

  // required bool repeat = 7;
  if (has_repeat()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->repeat(), output);
  }

  // optional int32 state = 8;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->state(), output);
  }

  // optional int32 action = 9;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->action(), output);
  }

}

int Button::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hoolai.gui.model.Label label = 1;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->label());
    }

    // required .hoolai.gui.model.Button.TitleNImage normal = 2;
    if (has_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->normal());
    }

    // optional .hoolai.gui.model.Button.TitleNImage selected = 3;
    if (has_selected()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->selected());
    }

    // optional .hoolai.gui.model.Button.TitleNImage highlighted = 4;
    if (has_highlighted()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->highlighted());
    }

    // optional .hoolai.gui.model.Button.TitleNImage disabled = 5;
    if (has_disabled()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->disabled());
    }

    // required bool zoom_on_touchdown = 6;
    if (has_zoom_on_touchdown()) {
      total_size += 1 + 1;
    }

    // required bool repeat = 7;
    if (has_repeat()) {
      total_size += 1 + 1;
    }

    // optional int32 state = 8;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 action = 9;
    if (has_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->action());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Button::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Button*>(&from));
}

void Button::MergeFrom(const Button& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_label()) {
      mutable_label()->::hoolai::gui::model::Label::MergeFrom(from.label());
    }
    if (from.has_normal()) {
      mutable_normal()->::hoolai::gui::model::Button_TitleNImage::MergeFrom(from.normal());
    }
    if (from.has_selected()) {
      mutable_selected()->::hoolai::gui::model::Button_TitleNImage::MergeFrom(from.selected());
    }
    if (from.has_highlighted()) {
      mutable_highlighted()->::hoolai::gui::model::Button_TitleNImage::MergeFrom(from.highlighted());
    }
    if (from.has_disabled()) {
      mutable_disabled()->::hoolai::gui::model::Button_TitleNImage::MergeFrom(from.disabled());
    }
    if (from.has_zoom_on_touchdown()) {
      set_zoom_on_touchdown(from.zoom_on_touchdown());
    }
    if (from.has_repeat()) {
      set_repeat(from.repeat());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_action()) {
      set_action(from.action());
    }
  }
}

void Button::CopyFrom(const Button& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Button::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000063) != 0x00000063) return false;

  if (has_label()) {
    if (!this->label().IsInitialized()) return false;
  }
  if (has_normal()) {
    if (!this->normal().IsInitialized()) return false;
  }
  if (has_selected()) {
    if (!this->selected().IsInitialized()) return false;
  }
  if (has_highlighted()) {
    if (!this->highlighted().IsInitialized()) return false;
  }
  if (has_disabled()) {
    if (!this->disabled().IsInitialized()) return false;
  }
  return true;
}

void Button::Swap(Button* other) {
  if (other != this) {
    std::swap(label_, other->label_);
    std::swap(normal_, other->normal_);
    std::swap(selected_, other->selected_);
    std::swap(highlighted_, other->highlighted_);
    std::swap(disabled_, other->disabled_);
    std::swap(zoom_on_touchdown_, other->zoom_on_touchdown_);
    std::swap(repeat_, other->repeat_);
    std::swap(state_, other->state_);
    std::swap(action_, other->action_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Button::GetTypeName() const {
  return "hoolai.gui.model.Button";
}


void Button::printDebugInfo() const 
{
#ifdef DEBUG
  printf("Button\n");
  printf("{\n");
  printf("label : \n");
  label().printDebugInfo();
  printf("normal : \n");
  normal().printDebugInfo();
  printf("selected : \n");
  selected().printDebugInfo();
  printf("highlighted : \n");
  highlighted().printDebugInfo();
  printf("disabled : \n");
  disabled().printDebugInfo();
  printf("zoom_on_touchdown : %d\n", zoom_on_touchdown());
  printf("repeat : %d\n", repeat());
  printf("state : %d\n", state());
  printf("action : %d\n", action());
  printf("}\n");
#endif
}

// ===================================================================

#ifndef _MSC_VER
const int EditBox::kLabelFieldNumber;
#endif  // !_MSC_VER

EditBox::EditBox()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EditBox::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  label_ = const_cast< ::hoolai::gui::model::Label*>(
      ::hoolai::gui::model::Label::internal_default_instance());
#else
  label_ = const_cast< ::hoolai::gui::model::Label*>(&::hoolai::gui::model::Label::default_instance());
#endif
}

EditBox::EditBox(const EditBox& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EditBox::SharedCtor() {
  _cached_size_ = 0;
  label_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EditBox::~EditBox() {
  SharedDtor();
}

void EditBox::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete label_;
  }
}

void EditBox::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EditBox& EditBox::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_guifile_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_guifile_2eproto();
#endif
  return *default_instance_;
}

EditBox* EditBox::default_instance_ = NULL;

EditBox* EditBox::New() const {
  return new EditBox;
}

void EditBox::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_label()) {
      if (label_ != NULL) label_->::hoolai::gui::model::Label::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EditBox::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hoolai.gui.model.Label label = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EditBox::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .hoolai.gui.model.Label label = 1;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->label(), output);
  }

}

int EditBox::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .hoolai.gui.model.Label label = 1;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->label());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EditBox::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EditBox*>(&from));
}

void EditBox::MergeFrom(const EditBox& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_label()) {
      mutable_label()->::hoolai::gui::model::Label::MergeFrom(from.label());
    }
  }
}

void EditBox::CopyFrom(const EditBox& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditBox::IsInitialized() const {

  if (has_label()) {
    if (!this->label().IsInitialized()) return false;
  }
  return true;
}

void EditBox::Swap(EditBox* other) {
  if (other != this) {
    std::swap(label_, other->label_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EditBox::GetTypeName() const {
  return "hoolai.gui.model.EditBox";
}


void EditBox::printDebugInfo() const 
{
#ifdef DEBUG
  printf("EditBox\n");
  printf("{\n");
  printf("label : \n");
  label().printDebugInfo();
  printf("}\n");
#endif
}

// ===================================================================

bool View_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const View_Type View::kView;
const View_Type View::kLabel;
const View_Type View::kImageView;
const View_Type View::kButton;
const View_Type View::kScrollView;
const View_Type View::kEditBox;
const View_Type View::Type_MIN;
const View_Type View::Type_MAX;
const int View::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int View::kIdFieldNumber;
const int View::kClassNameFieldNumber;
const int View::kTypeFieldNumber;
const int View::kXFieldNumber;
const int View::kYFieldNumber;
const int View::kWidthFieldNumber;
const int View::kHeightFieldNumber;
const int View::kBgColorFieldNumber;
const int View::kVisibleFieldNumber;
const int View::kLabelFieldNumber;
const int View::kImageFieldNumber;
const int View::kButtonFieldNumber;
const int View::kChildrenFieldNumber;
const int View::kTagFieldNumber;
const int View::kEditBoxFieldNumber;
#endif  // !_MSC_VER

View::View()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void View::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bg_color_ = const_cast< ::hoolai::gui::model::Color*>(
      ::hoolai::gui::model::Color::internal_default_instance());
#else
  bg_color_ = const_cast< ::hoolai::gui::model::Color*>(&::hoolai::gui::model::Color::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  label_ = const_cast< ::hoolai::gui::model::Label*>(
      ::hoolai::gui::model::Label::internal_default_instance());
#else
  label_ = const_cast< ::hoolai::gui::model::Label*>(&::hoolai::gui::model::Label::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  image_ = const_cast< ::hoolai::gui::model::ImageView*>(
      ::hoolai::gui::model::ImageView::internal_default_instance());
#else
  image_ = const_cast< ::hoolai::gui::model::ImageView*>(&::hoolai::gui::model::ImageView::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  button_ = const_cast< ::hoolai::gui::model::Button*>(
      ::hoolai::gui::model::Button::internal_default_instance());
#else
  button_ = const_cast< ::hoolai::gui::model::Button*>(&::hoolai::gui::model::Button::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  editbox_ = const_cast< ::hoolai::gui::model::EditBox*>(
      ::hoolai::gui::model::EditBox::internal_default_instance());
#else
  editbox_ = const_cast< ::hoolai::gui::model::EditBox*>(&::hoolai::gui::model::EditBox::default_instance());
#endif
}

View::View(const View& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void View::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  class_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0;
  x_ = 0;
  y_ = 0;
  width_ = 0;
  height_ = 0;
  bg_color_ = NULL;
  visible_ = false;
  label_ = NULL;
  image_ = NULL;
  button_ = NULL;
  tag_ = 0;
  editbox_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

View::~View() {
  SharedDtor();
}

void View::SharedDtor() {
  if (class_name_ != &::google::protobuf::internal::kEmptyString) {
    delete class_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete bg_color_;
    delete label_;
    delete image_;
    delete button_;
    delete editbox_;
  }
}

void View::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const View& View::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_guifile_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_guifile_2eproto();
#endif
  return *default_instance_;
}

View* View::default_instance_ = NULL;

View* View::New() const {
  return new View;
}

void View::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    if (has_class_name()) {
      if (class_name_ != &::google::protobuf::internal::kEmptyString) {
        class_name_->clear();
      }
    }
    type_ = 0;
    x_ = 0;
    y_ = 0;
    width_ = 0;
    height_ = 0;
    if (has_bg_color()) {
      if (bg_color_ != NULL) bg_color_->::hoolai::gui::model::Color::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    visible_ = false;
    if (has_label()) {
      if (label_ != NULL) label_->::hoolai::gui::model::Label::Clear();
    }
    if (has_image()) {
      if (image_ != NULL) image_->::hoolai::gui::model::ImageView::Clear();
    }
    if (has_button()) {
      if (button_ != NULL) button_->::hoolai::gui::model::Button::Clear();
    }
    tag_ = 0;
    if (has_editbox()) {
      if (editbox_ != NULL) editbox_->::hoolai::gui::model::EditBox::Clear();
    }
  }
  children_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool View::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_class_name;
        break;
      }

      // optional string class_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_class_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_class_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // required .hoolai.gui.model.View.Type type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hoolai::gui::model::View_Type_IsValid(value)) {
            set_type(static_cast< ::hoolai::gui::model::View_Type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_x;
        break;
      }

      // required float x = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_y;
        break;
      }

      // required float y = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_width;
        break;
      }

      // required float width = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_height;
        break;
      }

      // required float height = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_bg_color;
        break;
      }

      // optional .hoolai.gui.model.Color bg_color = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bg_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bg_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_visible;
        break;
      }

      // required bool visible = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_visible:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &visible_)));
          set_has_visible();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_label;
        break;
      }

      // optional .hoolai.gui.model.Label label = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_image;
        break;
      }

      // optional .hoolai.gui.model.ImageView image = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_button;
        break;
      }

      // optional .hoolai.gui.model.Button button = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_button:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_button()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_children;
        break;
      }

      // repeated .hoolai.gui.model.View children = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_children:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_children()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_children;
        if (input->ExpectTag(112)) goto parse_tag;
        break;
      }

      // optional int32 tag = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tag_)));
          set_has_tag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_editBox;
        break;
      }

      // optional .hoolai.gui.model.EditBox editBox = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_editBox:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_editbox()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void View::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string class_name = 2;
  if (has_class_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->class_name(), output);
  }

  // required .hoolai.gui.model.View.Type type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // required float x = 4;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->x(), output);
  }

  // required float y = 5;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->y(), output);
  }

  // required float width = 6;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->width(), output);
  }

  // required float height = 7;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->height(), output);
  }

  // optional .hoolai.gui.model.Color bg_color = 8;
  if (has_bg_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->bg_color(), output);
  }

  // required bool visible = 9;
  if (has_visible()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->visible(), output);
  }

  // optional .hoolai.gui.model.Label label = 10;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->label(), output);
  }

  // optional .hoolai.gui.model.ImageView image = 11;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->image(), output);
  }

  // optional .hoolai.gui.model.Button button = 12;
  if (has_button()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, this->button(), output);
  }

  // repeated .hoolai.gui.model.View children = 13;
  for (int i = 0; i < this->children_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->children(i), output);
  }

  // optional int32 tag = 14;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->tag(), output);
  }

  // optional .hoolai.gui.model.EditBox editBox = 15;
  if (has_editbox()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->editbox(), output);
  }

}

int View::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional string class_name = 2;
    if (has_class_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->class_name());
    }

    // required .hoolai.gui.model.View.Type type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required float x = 4;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 5;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float width = 6;
    if (has_width()) {
      total_size += 1 + 4;
    }

    // required float height = 7;
    if (has_height()) {
      total_size += 1 + 4;
    }

    // optional .hoolai.gui.model.Color bg_color = 8;
    if (has_bg_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bg_color());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required bool visible = 9;
    if (has_visible()) {
      total_size += 1 + 1;
    }

    // optional .hoolai.gui.model.Label label = 10;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->label());
    }

    // optional .hoolai.gui.model.ImageView image = 11;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->image());
    }

    // optional .hoolai.gui.model.Button button = 12;
    if (has_button()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->button());
    }

    // optional int32 tag = 14;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tag());
    }

    // optional .hoolai.gui.model.EditBox editBox = 15;
    if (has_editbox()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->editbox());
    }

  }
  // repeated .hoolai.gui.model.View children = 13;
  total_size += 1 * this->children_size();
  for (int i = 0; i < this->children_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->children(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void View::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const View*>(&from));
}

void View::MergeFrom(const View& from) {
  GOOGLE_CHECK_NE(&from, this);
  children_.MergeFrom(from.children_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_class_name()) {
      set_class_name(from.class_name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_bg_color()) {
      mutable_bg_color()->::hoolai::gui::model::Color::MergeFrom(from.bg_color());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_visible()) {
      set_visible(from.visible());
    }
    if (from.has_label()) {
      mutable_label()->::hoolai::gui::model::Label::MergeFrom(from.label());
    }
    if (from.has_image()) {
      mutable_image()->::hoolai::gui::model::ImageView::MergeFrom(from.image());
    }
    if (from.has_button()) {
      mutable_button()->::hoolai::gui::model::Button::MergeFrom(from.button());
    }
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_editbox()) {
      mutable_editbox()->::hoolai::gui::model::EditBox::MergeFrom(from.editbox());
    }
  }
}

void View::CopyFrom(const View& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool View::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000017c) != 0x0000017c) return false;

  if (has_bg_color()) {
    if (!this->bg_color().IsInitialized()) return false;
  }
  if (has_label()) {
    if (!this->label().IsInitialized()) return false;
  }
  if (has_image()) {
    if (!this->image().IsInitialized()) return false;
  }
  if (has_button()) {
    if (!this->button().IsInitialized()) return false;
  }
  for (int i = 0; i < children_size(); i++) {
    if (!this->children(i).IsInitialized()) return false;
  }
  if (has_editbox()) {
    if (!this->editbox().IsInitialized()) return false;
  }
  return true;
}

void View::Swap(View* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(class_name_, other->class_name_);
    std::swap(type_, other->type_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(bg_color_, other->bg_color_);
    std::swap(visible_, other->visible_);
    std::swap(label_, other->label_);
    std::swap(image_, other->image_);
    std::swap(button_, other->button_);
    children_.Swap(&other->children_);
    std::swap(tag_, other->tag_);
    std::swap(editbox_, other->editbox_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string View::GetTypeName() const {
  return "hoolai.gui.model.View";
}


void View::printDebugInfo() const 
{
#ifdef DEBUG
  printf("View\n");
  printf("{\n");
  printf("id : %d\n", id());
  printf("class_name : %s\n", class_name().c_str());
  printf("type : %d\n", type());
  printf("x : %f\n", x());
  printf("y : %f\n", y());
  printf("width : %f\n", width());
  printf("height : %f\n", height());
  printf("bg_color : \n");
  bg_color().printDebugInfo();
  printf("visible : %d\n", visible());
  printf("label : \n");
  label().printDebugInfo();
  printf("image : \n");
  image().printDebugInfo();
  printf("button : \n");
  button().printDebugInfo();
  printf("children : [\n");
  for(int i = 0; i < children_size(); ++i) {
    children(i).printDebugInfo();
  }
  printf("]\n");
  printf("tag : %d\n", tag());
  printf("editbox : \n");
  editbox().printDebugInfo();
  printf("}\n");
#endif
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace model
}  // namespace gui
}  // namespace hoolai

// @@protoc_insertion_point(global_scope)
